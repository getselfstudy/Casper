{"version":3,"sources":["components/index.js"],"names":["window","JSCompiler_renameProperty","prop","workingURL","resolveDoc","CSS_URL_RX","ABS_URL","resolveUrl","url","baseURI","test","undefined","u","URL","pathname","href","e","document","location","implementation","createHTMLDocument","base","createElement","head","appendChild","anchor","body","resolveCss","cssText","replace","m","pre","post","pathFromUrl","substring","lastIndexOf","resolveUrl$1","useShadow","ShadyDOM","useNativeCSSProperties","Boolean","ShadyCSS","nativeCss","useNativeCustomElements","customElements","polyfillWrapFlushCallback","rootPath","setRootPath","path","sanitizeDOMValue","setSanitizeDOMValue","newSanitizeDOMValue","passiveTouchGestures","setPassiveTouchGestures","usePassive","settings","dedupeId","MixinFunction","prototype","__mixinApplications","__mixinSet","dedupingMixin","mixin","mixinApplications","WeakMap","mixinDedupeId","baseSet","map","extended","get","set","mixinSet","Object","create","MODULE_STYLE_LINK_SELECTOR","INCLUDE_ATTR","SHADY_UNSCOPED_ATTR","importModule","moduleId","PolymerDomModule","import","styleForImport","importDoc","importCss","textContent","style","templateWithAssetPath","stylesFromModules","moduleIds","modules","trim","split","styles","i","length","push","stylesFromModule","console","warn","_styles","_stylesFromModuleImports","template","querySelector","stylesFromTemplate","assetpath","e$","content","querySelectorAll","include","getAttribute","filter","item","index","self","indexOf","stylesFromModuleImports","module","p$","p","unscoped","hasAttribute","_unscopedStyle","setAttribute","_style","cssFromModules","cssFromModule","_cssText","_cssFromModuleImports","t","cssFromTemplate","parentNode","removeChild","cssFromModuleImports","styleGather","lcModules","findModule","id","toLowerCase","styleOutsideTemplateCheck","inst","DomModule","HTMLElement","observedAttributes","[object Object]","selector","name","old","value","namespace","this","register","__assetpath","owner","HTMLImports","importForElement","ownerDocument","define","domModule","isPath","root","dotIndex","slice","isAncestor","isDescendant","translate","newBase","matches","normalize","Array","isArray","parts","args","toString","j","join","info","last","isDeep","caseMap","DASH_TO_CAMEL","CAMEL_TO_DASH","dashToCamelCase","dash","toUpperCase","camelToDashCase","camel","caseMap$1","microtaskCurrHandle","microtaskLastHandle","microtaskCallbacks","microtaskNodeContent","microtaskNode","createTextNode","microtaskFlush","len","cb","setTimeout","splice","MutationObserver","observe","characterData","timeOut","after","delay","run","fn","handle","clearTimeout","animationFrame","requestAnimationFrame","cancelAnimationFrame","idlePeriod","requestIdleCallback","cancelIdleCallback","microTask","callback","idx","Error","async","microtask","PropertiesChanged","superClass","props","proto","_createPropertyAccessor","property","readOnly","_addPropertyToAttributeMap","hasOwnProperty","__dataHasAccessor","assign","_definePropertyAccessor","__dataAttributes","attr","constructor","attributeNameForProperty","defineProperty","_getProperty","_setProperty","super","__dataEnabled","__dataReady","__dataInvalid","__data","__dataPending","__dataOld","__dataInstanceProps","__serializing","_initializeProperties","_flushProperties","_setPendingProperty","_invalidateProperties","ext","changed","_shouldPropertyChange","_initializeInstanceProperties","ready","changedProps","_shouldPropertiesChange","_propertiesChanged","currentProps","oldProps","_attributeToProperty","attributeChangedCallback","attribute","type","_deserializeValue","typeForProperty","arguments","_valueToNodeAttribute","node","str","_serializeValue","removeAttribute","Number","propertiesChanged","caseMap$2","nativeProperties","getOwnPropertyNames","getPrototypeOf","saveAccessorValue","model","__dataProto","PropertyAccessors","a$","_initializeProtoProperties","el","Date","JSON","stringify","x","outValue","parse","isNaN","String","propertyAccessors","templateExtensions","dom-if","dom-repeat","wrapTemplateExtension","is","replaceChild","attributes","findTemplateNode","nodeInfo","parent","parentInfo","n","firstChild","nextSibling","parentIndex","applyIdToMap","applyEventListener","events","_addMethodEventListenerToNode","applyTemplateContent","templateInfo","_templateInfo","createNodeEventHandler","context","eventName","methodName","_methodHost","detail","TemplateStamp","outerTemplateInfo","nodeInfoList","stripWhiteSpace","_parseTemplateContent","_parseTemplateNode","noted","element","localName","hasInsertionPoint","_parseTemplateNestedTemplate","_parseTemplateChildNodes","hasAttributes","_parseTemplateNodeAttributes","next","nodeType","Node","TEXT_NODE","childInfo","infoIndex","_parseTemplate","createDocumentFragment","attrs","from","a","_parseTemplateNodeAttribute","HTMLTemplateElement","decorate","dom","importNode","__noInsertionPoint","nodes","nodeList","$","l","handler","_addEventListenerToNode","addEventListener","removeEventListener","templateStamp","CaseMap","dedupeId$1","TYPES","COMPUTE","REFLECT","NOTIFY","PROPAGATE","OBSERVE","READ_ONLY","capitalAttributeRegex","DataTrigger","DataEffect","PropertyEffectsType","ensureOwnEffectMap","effects","protoFx","instFx","runEffects","hasPaths","extraArgs","ran","runEffectsForProperty","fxs","fx","lastRun","pathMatchesTrigger","trigger","triggerPath","structured","wildcard","runObserverEffect","method","changedProp","call","dynamicFn","runNotifyEffects","notifyProps","notified","host","notifyPath","__dataHost","rootProperty","dispatchNotifyEvent","queueProperty","dispatchEvent","CustomEvent","runNotifyEffect","handleNotification","event","fromProp","toPath","negate","fromPath","target","_setPendingPropertyOrPath","runReflectEffect","attrName","_propertyToAttribute","runComputedEffects","computeEffects","inputProps","runComputedEffect","result","runMethodEffect","computedProp","methodInfo","computeLinkedPaths","links","__dataLinkedPaths","link","b","addBinding","kind","literal","bindings","binding","isCompound","shouldAddListener","listenerEvent","listenerNegate","part","compoundIndex","addEffectForBindingPart","dependencies","evaluator","parseArg","_addTemplatePropertyEffect","runBindingEffect","source","__isPropertyEffectsClient","_enqueueClient","applyBindingValue","_evaluateBinding","computeBindingValue","_setUnmanagedPropertyToNode","storage","__dataCompoundStorage","mode","setupBindings","setupCompoundStorage","addNotifyListener","literals","createMethodEffect","sig","effectFn","static","arg","_addPropertyEffect","marshalArgs","apply","emptyArray","IDENT","NUMBER","SQUOTE_STRING","DQUOTE_STRING","STRING","ARGUMENT","ARGUMENTS","ARGUMENT_LIST","BINDING","OPEN_BRACKET","CLOSE_BRACKET","NEGATE","EXPRESSION","bindingRegex","RegExp","literalFromParts","s","parseMethod","expression","match","parseArgs","argList","rawArg","fc","data","values","v","baseChanged","matches$$1","notifySplices","array","splices","splicesPath","indexSplices","notifySplice","addedCount","removed","object","upper","PropertyEffects","propertyEffectsBase","__dataCounter","__dataClientsReady","__dataPendingClients","__dataToNotify","__dataHasPaths","__dataTemp","__dataClientsInitialized","__computeEffects","__reflectEffects","__notifyEffects","__propagateEffects","__observeEffects","__readOnly","__templateInfo","PROPERTY_EFFECT_TYPES","hostStack","registerHost","effect","_hasPropertyEffect","shouldNotify","isPathNotification","isPath$$1","prevProps","client","__enableOrFlushClients","_readyClients","clients","_enableProperties","setReadOnly","_flushClients","_propagatePropertyChanges","propertyEffects","nextTemplateInfo","to","root$$1","items","ret","hadLength","pop","start","deleteCount","Math","floor","shift","unshift","propPath","protectedSetter","_createPropertyObserver","_createMethodObserver","_createNotifyingProperty","_createReadOnlyProperty","_createReflectedProperty","_createComputedProperty","_bindTemplate","instanceBinding","wasPreBound","__templateInfoLast","previousTemplateInfo","hostProps","beginHosting","_stampTemplate","endHosting","childNodes","_parseBindings","origName","text","lastIndex","exec","customEvent","notifyEvent","colon","signature","dynamicFns","HostStack","stack","stackLen","normalizeProperties","output","o","PropertiesMixin","superPropertiesClass","superCtor","ownProperties","properties","__ownProperties","_properties","keys","finalize","__finalized","_finalizeClass","createProperties","__properties","connectedCallback","disconnectedCallback","propertiesMixin","bundledImportMeta","meta","ElementMixin","polymerElementBase","observers","__ownObservers","createObservers","error","cloneNode","_template","allProps","computed","_hasReadOnlyEffect","reflectToAttribute","_hasReflectEffect","notify","_hasNotifyEffect","observer","importPath","importMeta","_importPath","instanceCount","_finalizeTemplate","__propertyDefaults","propertyDefaults","_hasAccessor","__polymerFinalized","klass","templateStyles","stylesWithImports","linkedStyles","firstTemplateChild","firstElementChild","_processStyleText","insertBefore","templateStyleIndex","templateStyle","prepareTemplate","processElementStyles","styleElement","_attachDom","attachShadow","shadowRoot","styleSubtree","registrations","_regLog","log","dumpRegistrations","forEach","updateStyles","styleDocument","elementMixin","LiteralString","string","literalValue","htmlValue","html","strings","innerHTML","reduce","acc","htmlLiteral","htmlTag","PolymerElement","polymerElement","truthy","val","Answer","config","expect","answered","showCorrect","review","order","stopPropagation","bubbles","composed","hide","oldConfig","className","isCorrect","checked","wronglySelected","rootClassName","MyPolymerElement","prop1","truthy$1","Question","confidence","answer","preserve","showConfidence","hasConfidence","show","nofify","correct","_listener","_selfstudyAnswer","bind","answers","expected","exclusive","random","sort","previous","choice","_checkConfidence","key","temp","all","truthy$2","QuestionSet","questions","question","pos","_checkAnswers"],"mappings":"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","file":"index.js","sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/window.JSCompiler_renameProperty = function (prop) {\n  return prop;\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */\n\nlet CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\nlet ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\nlet workingURL;\nlet resolveDoc; /**\n                 * Resolves the given URL against the provided `baseUri'.\n                 *\n                 * Note that this function performs no resolution for URLs that start\n                 * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n                 * URL resolution, use `window.URL`.\n                 *\n                 * @param {string} url Input URL to resolve\n                 * @param {?string=} baseURI Base URI to resolve the URL against\n                 * @return {string} resolved URL\n                 */\n\nfunction resolveUrl(url, baseURI) {\n  if (url && ABS_URL.test(url)) {\n    return url;\n  } // Lazy feature detection.\n\n\n  if (workingURL === undefined) {\n    workingURL = false;\n\n    try {\n      const u = new URL('b', 'http://a');\n      u.pathname = 'c%20d';\n      workingURL = u.href === 'http://a/c%20d';\n    } catch (e) {// silently fail\n    }\n  }\n\n  if (!baseURI) {\n    baseURI = document.baseURI || window.location.href;\n  }\n\n  if (workingURL) {\n    return new URL(url, baseURI).href;\n  } // Fallback to creating an anchor into a disconnected document.\n\n\n  if (!resolveDoc) {\n    resolveDoc = document.implementation.createHTMLDocument('temp');\n    resolveDoc.base = resolveDoc.createElement('base');\n    resolveDoc.head.appendChild(resolveDoc.base);\n    resolveDoc.anchor = resolveDoc.createElement('a');\n    resolveDoc.body.appendChild(resolveDoc.anchor);\n  }\n\n  resolveDoc.base.href = baseURI;\n  resolveDoc.anchor.href = url;\n  return resolveDoc.anchor.href || url;\n} /**\n   * Resolves any relative URL's in the given CSS text against the provided\n   * `ownerDocument`'s `baseURI`.\n   *\n   * @param {string} cssText CSS text to process\n   * @param {string} baseURI Base URI to resolve the URL against\n   * @return {string} Processed CSS text with resolved URL's\n   */\n\nfunction resolveCss(cssText, baseURI) {\n  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\n    return pre + '\\'' + resolveUrl(url.replace(/[\"']/g, ''), baseURI) + '\\'' + post;\n  });\n} /**\n   * Returns a path from a given `url`. The path includes the trailing\n   * `/` from the url.\n   *\n   * @param {string} url Input URL to transform\n   * @return {string} resolved path\n   */\n\nfunction pathFromUrl(url) {\n  return url.substring(0, url.lastIndexOf('/') + 1);\n}\n\nvar resolveUrl$1 = {\n  resolveUrl: resolveUrl,\n  resolveCss: resolveCss,\n  pathFromUrl: pathFromUrl\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */\nconst useShadow = !window.ShadyDOM;\nconst useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);\nconst useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback; /**\n                                                                                   * Globally settable property that is automatically assigned to\n                                                                                   * `ElementMixin` instances, useful for binding in templates to\n                                                                                   * make URL's relative to an application's root.  Defaults to the main\n                                                                                   * document URL, but can be overridden by users.  It may be useful to set\n                                                                                   * `rootPath` to provide a stable application mount path when\n                                                                                   * using client side routing.\n                                                                                   */\nlet rootPath = undefined || pathFromUrl(document.baseURI || window.location.href); /**\n                                                                                    * Sets the global rootPath property used by `ElementMixin` and\n                                                                                    * available via `rootPath`.\n                                                                                    *\n                                                                                    * @param {string} path The new root path\n                                                                                    * @return {void}\n                                                                                    */\n\nconst setRootPath = function (path) {\n  rootPath = path;\n}; /**\n    * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:\n    *\n    *     Polymer = {\n    *       sanitizeDOMValue: function(value, name, type, node) { ... }\n    *     }\n    *\n    * Where:\n    *\n    * `value` is the value to sanitize.\n    * `name` is the name of an attribute or property (for example, href).\n    * `type` indicates where the value is being inserted: one of property, attribute, or text.\n    * `node` is the node where the value is being inserted.\n    *\n    * @type {(function(*,string,string,Node):*)|undefined}\n    */\n\nlet sanitizeDOMValue = undefined; /**\n                                   * Sets the global sanitizeDOMValue available via this module's exported\n                                   * `sanitizeDOMValue` variable.\n                                   *\n                                   * @param {(function(*,string,string,Node):*)|undefined} newSanitizeDOMValue the global sanitizeDOMValue callback\n                                   * @return {void}\n                                   */\n\nconst setSanitizeDOMValue = function (newSanitizeDOMValue) {\n  sanitizeDOMValue = newSanitizeDOMValue;\n}; /**\n    * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.\n    * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother\n    * scrolling performance.\n    * Defaults to `false` for backwards compatibility.\n    */\n\nlet passiveTouchGestures = false; /**\n                                   * Sets `passiveTouchGestures` globally for all elements using Polymer Gestures.\n                                   *\n                                   * @param {boolean} usePassive enable or disable passive touch gestures globally\n                                   * @return {void}\n                                   */\n\nconst setPassiveTouchGestures = function (usePassive) {\n  passiveTouchGestures = usePassive;\n};\n\nvar settings = {\n  useShadow: useShadow,\n  useNativeCSSProperties: useNativeCSSProperties,\n  useNativeCustomElements: useNativeCustomElements,\n\n  get rootPath() {\n    return rootPath;\n  },\n\n  setRootPath: setRootPath,\n\n  get sanitizeDOMValue() {\n    return sanitizeDOMValue;\n  },\n\n  setSanitizeDOMValue: setSanitizeDOMValue,\n\n  get passiveTouchGestures() {\n    return passiveTouchGestures;\n  },\n\n  setPassiveTouchGestures: setPassiveTouchGestures\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ // unique global id for deduping mixins.\n\nlet dedupeId = 0; /**\n                   * @constructor\n                   * @extends {Function}\n                   * @private\n                   */\n\nfunction MixinFunction() {} /** @type {(WeakMap | undefined)} */\n\nMixinFunction.prototype.__mixinApplications; /** @type {(Object | undefined)} */\nMixinFunction.prototype.__mixinSet; /* eslint-disable valid-jsdoc */ /**\n                                                                      * Wraps an ES6 class expression mixin such that the mixin is only applied\n                                                                      * if it has not already been applied its base argument. Also memoizes mixin\n                                                                      * applications.\n                                                                      *\n                                                                      * @template T\n                                                                      * @param {T} mixin ES6 class expression mixin to wrap\n                                                                      * @return {T}\n                                                                      * @suppress {invalidCasts}\n                                                                      */\n\nconst dedupingMixin = function (mixin) {\n  let mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;\n\n  if (!mixinApplications) {\n    mixinApplications = new WeakMap(); /** @type {!MixinFunction} */\n    mixin.__mixinApplications = mixinApplications;\n  } // maintain a unique id for each mixin\n\n\n  let mixinDedupeId = dedupeId++;\n\n  function dedupingMixin(base) {\n    let baseSet = /** @type {!MixinFunction} */base.__mixinSet;\n\n    if (baseSet && baseSet[mixinDedupeId]) {\n      return base;\n    }\n\n    let map = mixinApplications;\n    let extended = map.get(base);\n\n    if (!extended) {\n      extended = /** @type {!Function} */mixin(base);\n      map.set(base, extended);\n    } // copy inherited mixin set from the extended class, or the base class\n    // NOTE: we avoid use of Set here because some browser (IE11)\n    // cannot extend a base Set via the constructor.\n\n\n    let mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);\n    mixinSet[mixinDedupeId] = true; /** @type {!MixinFunction} */\n    extended.__mixinSet = mixinSet;\n    return extended;\n  }\n\n  return dedupingMixin;\n}; /* eslint-enable valid-jsdoc */\n\nvar mixin = {\n  dedupingMixin: dedupingMixin\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */\nconst MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';\nconst INCLUDE_ATTR = 'include';\nconst SHADY_UNSCOPED_ATTR = 'shady-unscoped';\n\nfunction importModule(moduleId) {\n  const /** DomModule */PolymerDomModule = customElements.get('dom-module');\n\n  if (!PolymerDomModule) {\n    return null;\n  }\n\n  return PolymerDomModule.import(moduleId);\n}\n\nfunction styleForImport(importDoc) {\n  // NOTE: polyfill affordance.\n  // under the HTMLImports polyfill, there will be no 'body',\n  // but the import pseudo-doc can be used directly.\n  let container = importDoc.body ? importDoc.body : importDoc;\n  const importCss = resolveCss(container.textContent, importDoc.baseURI);\n  const style = document.createElement('style');\n  style.textContent = importCss;\n  return style;\n} /** @typedef {{assetpath: string}} */\n\nlet templateWithAssetPath; // eslint-disable-line no-unused-vars\n/**\n * Module with utilities for collection CSS text from `<templates>`, external\n * stylesheets, and `dom-module`s.\n *\n * @summary Module with utilities for collection CSS text from various sources.\n */\n`TODO(modulizer): A namespace named Polymer.StyleGather was\ndeclared here. The surrounding comments should be reviewed,\nand this string can then be deleted`; /**\n                                       * Returns a list of <style> elements in a space-separated list of `dom-module`s.\n                                       *\n                                       * @function\n                                       * @param {string} moduleIds List of dom-module id's within which to\n                                       * search for css.\n                                       * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements\n                                       * @this {StyleGather}\n                                       */\n\nfunction stylesFromModules(moduleIds) {\n  const modules = moduleIds.trim().split(/\\s+/);\n  const styles = [];\n\n  for (let i = 0; i < modules.length; i++) {\n    styles.push(...stylesFromModule(modules[i]));\n  }\n\n  return styles;\n} /**\n   * Returns a list of <style> elements in a given `dom-module`.\n   * Styles in a `dom-module` can come either from `<style>`s within the\n   * first `<template>`, or else from one or more\n   * `<link rel=\"import\" type=\"css\">` links outside the template.\n   *\n   * @param {string} moduleId dom-module id to gather styles from\n   * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n   * @this {StyleGather}\n   */\n\nfunction stylesFromModule(moduleId) {\n  const m = importModule(moduleId);\n\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n    return [];\n  }\n\n  if (m._styles === undefined) {\n    const styles = []; // module imports: <link rel=\"import\" type=\"css\">\n\n    styles.push(..._stylesFromModuleImports(m)); // include css from the first template in the module\n\n    const template = m.querySelector('template');\n\n    if (template) {\n      styles.push(...stylesFromTemplate(template, /** @type {templateWithAssetPath} */m.assetpath));\n    }\n\n    m._styles = styles;\n  }\n\n  return m._styles;\n} /**\n   * Returns the `<style>` elements within a given template.\n   *\n   * @param {!HTMLTemplateElement} template Template to gather styles from\n   * @param {string} baseURI baseURI for style content\n   * @return {!Array<!HTMLStyleElement>} Array of styles\n   * @this {StyleGather}\n   */\n\nfunction stylesFromTemplate(template, baseURI) {\n  if (!template._styles) {\n    const styles = []; // if element is a template, get content from its .content\n\n    const e$ = template.content.querySelectorAll('style');\n\n    for (let i = 0; i < e$.length; i++) {\n      let e = e$[i]; // support style sharing by allowing styles to \"include\"\n      // other dom-modules that contain styling\n\n      let include = e.getAttribute(INCLUDE_ATTR);\n\n      if (include) {\n        styles.push(...stylesFromModules(include).filter(function (item, index, self) {\n          return self.indexOf(item) === index;\n        }));\n      }\n\n      if (baseURI) {\n        e.textContent = resolveCss(e.textContent, baseURI);\n      }\n\n      styles.push(e);\n    }\n\n    template._styles = styles;\n  }\n\n  return template._styles;\n} /**\n   * Returns a list of <style> elements  from stylesheets loaded via `<link rel=\"import\" type=\"css\">` links within the specified `dom-module`.\n   *\n   * @param {string} moduleId Id of `dom-module` to gather CSS from\n   * @return {!Array<!HTMLStyleElement>} Array of contained styles.\n   * @this {StyleGather}\n   */\n\nfunction stylesFromModuleImports(moduleId) {\n  let m = importModule(moduleId);\n  return m ? _stylesFromModuleImports(m) : [];\n} /**\n   * @this {StyleGather}\n   * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n   * @return {!Array<!HTMLStyleElement>} Array of contained styles\n   */\n\nfunction _stylesFromModuleImports(module) {\n  const styles = [];\n  const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);\n\n  for (let i = 0; i < p$.length; i++) {\n    let p = p$[i];\n\n    if (p.import) {\n      const importDoc = p.import;\n      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);\n\n      if (unscoped && !importDoc._unscopedStyle) {\n        const style = styleForImport(importDoc);\n        style.setAttribute(SHADY_UNSCOPED_ATTR, '');\n        importDoc._unscopedStyle = style;\n      } else if (!importDoc._style) {\n        importDoc._style = styleForImport(importDoc);\n      }\n\n      styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);\n    }\n  }\n\n  return styles;\n} /**\n   *\n   * Returns CSS text of styles in a space-separated list of `dom-module`s.\n   * Note: This method is deprecated, use `stylesFromModules` instead.\n   *\n   * @deprecated\n   * @param {string} moduleIds List of dom-module id's within which to\n   * search for css.\n   * @return {string} Concatenated CSS content from specified `dom-module`s\n   * @this {StyleGather}\n   */\n\nfunction cssFromModules(moduleIds) {\n  let modules = moduleIds.trim().split(/\\s+/);\n  let cssText = '';\n\n  for (let i = 0; i < modules.length; i++) {\n    cssText += cssFromModule(modules[i]);\n  }\n\n  return cssText;\n} /**\n   * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`\n   * can come either from `<style>`s within the first `<template>`, or else\n   * from one or more `<link rel=\"import\" type=\"css\">` links outside the\n   * template.\n   *\n   * Any `<styles>` processed are removed from their original location.\n   * Note: This method is deprecated, use `styleFromModule` instead.\n   *\n   * @deprecated\n   * @param {string} moduleId dom-module id to gather styles from\n   * @return {string} Concatenated CSS content from specified `dom-module`\n   * @this {StyleGather}\n   */\n\nfunction cssFromModule(moduleId) {\n  let m = importModule(moduleId);\n\n  if (m && m._cssText === undefined) {\n    // module imports: <link rel=\"import\" type=\"css\">\n    let cssText = _cssFromModuleImports(m); // include css from the first template in the module\n\n\n    let t = m.querySelector('template');\n\n    if (t) {\n      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */m.assetpath);\n    }\n\n    m._cssText = cssText || null;\n  }\n\n  if (!m) {\n    console.warn('Could not find style data in module named', moduleId);\n  }\n\n  return m && m._cssText || '';\n} /**\n   * Returns CSS text of `<styles>` within a given template.\n   *\n   * Any `<styles>` processed are removed from their original location.\n   * Note: This method is deprecated, use `styleFromTemplate` instead.\n   *\n   * @deprecated\n   * @param {!HTMLTemplateElement} template Template to gather styles from\n   * @param {string} baseURI Base URI to resolve the URL against\n   * @return {string} Concatenated CSS content from specified template\n   * @this {StyleGather}\n   */\n\nfunction cssFromTemplate(template, baseURI) {\n  let cssText = '';\n  const e$ = stylesFromTemplate(template, baseURI); // if element is a template, get content from its .content\n\n  for (let i = 0; i < e$.length; i++) {\n    let e = e$[i];\n\n    if (e.parentNode) {\n      e.parentNode.removeChild(e);\n    }\n\n    cssText += e.textContent;\n  }\n\n  return cssText;\n} /**\n   * Returns CSS text from stylesheets loaded via `<link rel=\"import\" type=\"css\">`\n   * links within the specified `dom-module`.\n   *\n   * Note: This method is deprecated, use `stylesFromModuleImports` instead.\n   *\n   * @deprecated\n   *\n   * @param {string} moduleId Id of `dom-module` to gather CSS from\n   * @return {string} Concatenated CSS content from links in specified `dom-module`\n   * @this {StyleGather}\n   */\n\nfunction cssFromModuleImports(moduleId) {\n  let m = importModule(moduleId);\n  return m ? _cssFromModuleImports(m) : '';\n} /**\n   * @deprecated\n   * @this {StyleGather}\n   * @param {!HTMLElement} module dom-module element that could contain `<link rel=\"import\" type=\"css\">` styles\n   * @return {string} Concatenated CSS content from links in the dom-module\n   */\n\nfunction _cssFromModuleImports(module) {\n  let cssText = '';\n\n  let styles = _stylesFromModuleImports(module);\n\n  for (let i = 0; i < styles.length; i++) {\n    cssText += styles[i].textContent;\n  }\n\n  return cssText;\n}\n\nvar styleGather = {\n  stylesFromModules: stylesFromModules,\n  stylesFromModule: stylesFromModule,\n  stylesFromTemplate: stylesFromTemplate,\n  stylesFromModuleImports: stylesFromModuleImports,\n  cssFromModules: cssFromModules,\n  cssFromModule: cssFromModule,\n  cssFromTemplate: cssFromTemplate,\n  cssFromModuleImports: cssFromModuleImports\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */\nlet modules = {};\nlet lcModules = {};\n\nfunction findModule(id) {\n  return modules[id] || lcModules[id.toLowerCase()];\n}\n\nfunction styleOutsideTemplateCheck(inst) {\n  if (inst.querySelector('style')) {\n    console.warn('dom-module %s has style outside template', inst.id);\n  }\n} /**\n   * The `dom-module` element registers the dom it contains to the name given\n   * by the module's id attribute. It provides a unified database of dom\n   * accessible via its static `import` API.\n   *\n   * A key use case of `dom-module` is for providing custom element `<template>`s\n   * via HTML imports that are parsed by the native HTML parser, that can be\n   * relocated during a bundling pass and still looked up by `id`.\n   *\n   * Example:\n   *\n   *     <dom-module id=\"foo\">\n   *       <img src=\"stuff.png\">\n   *     </dom-module>\n   *\n   * Then in code in some other location that cannot access the dom-module above\n   *\n   *     let img = customElements.get('dom-module').import('foo', 'img');\n   *\n   * @customElement\n   * @extends HTMLElement\n   * @summary Custom element that provides a registry of relocatable DOM content\n   *   by `id` that is agnostic to bundling.\n   * @unrestricted\n   */\n\nclass DomModule extends HTMLElement {\n  static get observedAttributes() {\n    return ['id'];\n  } /**\n     * Retrieves the element specified by the css `selector` in the module\n     * registered by `id`. For example, this.import('foo', 'img');\n     * @param {string} id The id of the dom-module in which to search.\n     * @param {string=} selector The css selector by which to find the element.\n     * @return {Element} Returns the element which matches `selector` in the\n     * module registered at the specified `id`.\n     */\n\n  static import(id, selector) {\n    if (id) {\n      let m = findModule(id);\n\n      if (m && selector) {\n        return m.querySelector(selector);\n      }\n\n      return m;\n    }\n\n    return null;\n  } /* eslint-disable no-unused-vars */ /**\n                                         * @param {string} name Name of attribute.\n                                         * @param {?string} old Old value of attribute.\n                                         * @param {?string} value Current value of attribute.\n                                         * @param {?string} namespace Attribute namespace.\n                                         * @return {void}\n                                         * @override\n                                         */\n\n  attributeChangedCallback(name, old, value, namespace) {\n    if (old !== value) {\n      this.register();\n    }\n  } /* eslint-enable no-unused-args */ /**\n                                        * The absolute URL of the original location of this `dom-module`.\n                                        *\n                                        * This value will differ from this element's `ownerDocument` in the\n                                        * following ways:\n                                        * - Takes into account any `assetpath` attribute added during bundling\n                                        *   to indicate the original location relative to the bundled location\n                                        * - Uses the HTMLImports polyfill's `importForElement` API to ensure\n                                        *   the path is relative to the import document's location since\n                                        *   `ownerDocument` is not currently polyfilled\n                                        */\n\n  get assetpath() {\n    // Don't override existing assetpath.\n    if (!this.__assetpath) {\n      // note: assetpath set via an attribute must be relative to this\n      // element's location; accomodate polyfilled HTMLImports\n      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;\n      const url = resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);\n      this.__assetpath = pathFromUrl(url);\n    }\n\n    return this.__assetpath;\n  } /**\n     * Registers the dom-module at a given id. This method should only be called\n     * when a dom-module is imperatively created. For\n     * example, `document.createElement('dom-module').register('foo')`.\n     * @param {string=} id The id at which to register the dom-module.\n     * @return {void}\n     */\n\n  register(id) {\n    id = id || this.id;\n\n    if (id) {\n      this.id = id; // store id separate from lowercased id so that\n      // in all cases mixedCase id will stored distinctly\n      // and lowercase version is a fallback\n\n      modules[id] = this;\n      lcModules[id.toLowerCase()] = this;\n      styleOutsideTemplateCheck(this);\n    }\n  }\n\n}\n\nDomModule.prototype['modules'] = modules;\ncustomElements.define('dom-module', DomModule);\nvar domModule = {\n  DomModule: DomModule\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ /**\n       * Module with utilities for manipulating structured data path strings.\n       *\n       * @summary Module with utilities for manipulating structured data path strings.\n       */\n`TODO(modulizer): A namespace named Polymer.Path was\ndeclared here. The surrounding comments should be reviewed,\nand this string can then be deleted`; /**\n                                       * Returns true if the given string is a structured data path (has dots).\n                                       *\n                                       * Example:\n                                       *\n                                       * ```\n                                       * isPath('foo.bar.baz') // true\n                                       * isPath('foo')         // false\n                                       * ```\n                                       *\n                                       * @param {string} path Path string\n                                       * @return {boolean} True if the string contained one or more dots\n                                       */\n\nfunction isPath(path) {\n  return path.indexOf('.') >= 0;\n} /**\n   * Returns the root property name for the given path.\n   *\n   * Example:\n   *\n   * ```\n   * root('foo.bar.baz') // 'foo'\n   * root('foo')         // 'foo'\n   * ```\n   *\n   * @param {string} path Path string\n   * @return {string} Root property name\n   */\n\nfunction root(path) {\n  let dotIndex = path.indexOf('.');\n\n  if (dotIndex === -1) {\n    return path;\n  }\n\n  return path.slice(0, dotIndex);\n} /**\n   * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not\n   * Returns true if the given path is an ancestor of the base path.\n   *\n   * Example:\n   *\n   * ```\n   * isAncestor('foo.bar', 'foo')         // true\n   * isAncestor('foo.bar', 'foo.bar')     // false\n   * isAncestor('foo.bar', 'foo.bar.baz') // false\n   * ```\n   *\n   * @param {string} base Path string to test against.\n   * @param {string} path Path string to test.\n   * @return {boolean} True if `path` is an ancestor of `base`.\n   */\n\nfunction isAncestor(base, path) {\n  //     base.startsWith(path + '.');\n  return base.indexOf(path + '.') === 0;\n} /**\n   * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant\n   *\n   * Example:\n   *\n   * ```\n   * isDescendant('foo.bar', 'foo.bar.baz') // true\n   * isDescendant('foo.bar', 'foo.bar')     // false\n   * isDescendant('foo.bar', 'foo')         // false\n   * ```\n   *\n   * @param {string} base Path string to test against.\n   * @param {string} path Path string to test.\n   * @return {boolean} True if `path` is a descendant of `base`.\n   */\n\nfunction isDescendant(base, path) {\n  //     path.startsWith(base + '.');\n  return path.indexOf(base + '.') === 0;\n} /**\n   * Replaces a previous base path with a new base path, preserving the\n   * remainder of the path.\n   *\n   * User must ensure `path` has a prefix of `base`.\n   *\n   * Example:\n   *\n   * ```\n   * translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'\n   * ```\n   *\n   * @param {string} base Current base string to remove\n   * @param {string} newBase New base string to replace with\n   * @param {string} path Path to translate\n   * @return {string} Translated string\n   */\n\nfunction translate(base, newBase, path) {\n  return newBase + path.slice(base.length);\n} /**\n   * @param {string} base Path string to test against\n   * @param {string} path Path string to test\n   * @return {boolean} True if `path` is equal to `base`\n   * @this {Path}\n   */\n\nfunction matches(base, path) {\n  return base === path || isAncestor(base, path) || isDescendant(base, path);\n} /**\n   * Converts array-based paths to flattened path.  String-based paths\n   * are returned as-is.\n   *\n   * Example:\n   *\n   * ```\n   * normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'\n   * normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'\n   * ```\n   *\n   * @param {string | !Array<string|number>} path Input path\n   * @return {string} Flattened path\n   */\n\nfunction normalize(path) {\n  if (Array.isArray(path)) {\n    let parts = [];\n\n    for (let i = 0; i < path.length; i++) {\n      let args = path[i].toString().split('.');\n\n      for (let j = 0; j < args.length; j++) {\n        parts.push(args[j]);\n      }\n    }\n\n    return parts.join('.');\n  } else {\n    return path;\n  }\n} /**\n   * Splits a path into an array of property names. Accepts either arrays\n   * of path parts or strings.\n   *\n   * Example:\n   *\n   * ```\n   * split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']\n   * split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']\n   * ```\n   *\n   * @param {string | !Array<string|number>} path Input path\n   * @return {!Array<string>} Array of path parts\n   * @this {Path}\n   * @suppress {checkTypes}\n   */\n\nfunction split(path) {\n  if (Array.isArray(path)) {\n    return normalize(path).split('.');\n  }\n\n  return path.toString().split('.');\n} /**\n   * Reads a value from a path.  If any sub-property in the path is `undefined`,\n   * this method returns `undefined` (will never throw.\n   *\n   * @param {Object} root Object from which to dereference path from\n   * @param {string | !Array<string|number>} path Path to read\n   * @param {Object=} info If an object is provided to `info`, the normalized\n   *  (flattened) path will be set to `info.path`.\n   * @return {*} Value at path, or `undefined` if the path could not be\n   *  fully dereferenced.\n   * @this {Path}\n   */\n\nfunction get(root, path, info) {\n  let prop = root;\n  let parts = split(path); // Loop over path parts[0..n-1] and dereference\n\n  for (let i = 0; i < parts.length; i++) {\n    if (!prop) {\n      return;\n    }\n\n    let part = parts[i];\n    prop = prop[part];\n  }\n\n  if (info) {\n    info.path = parts.join('.');\n  }\n\n  return prop;\n} /**\n   * Sets a value to a path.  If any sub-property in the path is `undefined`,\n   * this method will no-op.\n   *\n   * @param {Object} root Object from which to dereference path from\n   * @param {string | !Array<string|number>} path Path to set\n   * @param {*} value Value to set to path\n   * @return {string | undefined} The normalized version of the input path\n   * @this {Path}\n   */\n\nfunction set(root, path, value) {\n  let prop = root;\n  let parts = split(path);\n  let last = parts[parts.length - 1];\n\n  if (parts.length > 1) {\n    // Loop over path parts[0..n-2] and dereference\n    for (let i = 0; i < parts.length - 1; i++) {\n      let part = parts[i];\n      prop = prop[part];\n\n      if (!prop) {\n        return;\n      }\n    } // Set value to object at end of path\n\n\n    prop[last] = value;\n  } else {\n    // Simple property set\n    prop[path] = value;\n  }\n\n  return parts.join('.');\n} /**\n   * Returns true if the given string is a structured data path (has dots).\n   *\n   * This function is deprecated.  Use `isPath` instead.\n   *\n   * Example:\n   *\n   * ```\n   * isDeep('foo.bar.baz') // true\n   * isDeep('foo')         // false\n   * ```\n   *\n   * @deprecated\n   * @param {string} path Path string\n   * @return {boolean} True if the string contained one or more dots\n   */\n\nconst isDeep = isPath;\nvar path = {\n  isPath: isPath,\n  root: root,\n  isAncestor: isAncestor,\n  isDescendant: isDescendant,\n  translate: translate,\n  matches: matches,\n  normalize: normalize,\n  split: split,\n  get: get,\n  set: set,\n  isDeep: isDeep\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */\nconst caseMap = {};\nconst DASH_TO_CAMEL = /-[a-z]/g;\nconst CAMEL_TO_DASH = /([A-Z])/g; /**\n                                   * @fileoverview Module with utilities for converting between \"dash-case\" and\n                                   * \"camelCase\" identifiers.\n                                   */ /**\n                                       * Converts \"dash-case\" identifier (e.g. `foo-bar-baz`) to \"camelCase\"\n                                       * (e.g. `fooBarBaz`).\n                                       *\n                                       * @param {string} dash Dash-case identifier\n                                       * @return {string} Camel-case representation of the identifier\n                                       */\n\nfunction dashToCamelCase(dash) {\n  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));\n} /**\n   * Converts \"camelCase\" identifier (e.g. `fooBarBaz`) to \"dash-case\"\n   * (e.g. `foo-bar-baz`).\n   *\n   * @param {string} camel Camel-case identifier\n   * @return {string} Dash-case representation of the identifier\n   */\n\nfunction camelToDashCase(camel) {\n  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());\n}\n\nvar caseMap$1 = {\n  dashToCamelCase: dashToCamelCase,\n  camelToDashCase: camelToDashCase\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ // Microtask implemented using Mutation Observer\n\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {\n  characterData: true\n});\n\nfunction microtaskFlush() {\n  const len = microtaskCallbacks.length;\n\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => {\n          throw e;\n        });\n      }\n    }\n  }\n\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n} /**\n   * Async interface wrapper around `setTimeout`.\n   *\n   * @namespace\n   * @summary Async interface wrapper around `setTimeout`.\n   */\n\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */after(delay) {\n    return {\n      run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n\n    };\n  },\n\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */cancel(handle) {\n    window.clearTimeout(handle);\n  }\n\n}; /**\n    * Async interface wrapper around `requestAnimationFrame`.\n    *\n    * @namespace\n    * @summary Async interface wrapper around `requestAnimationFrame`.\n    */\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n\n}; /**\n    * Async interface wrapper around `requestIdleCallback`.  Falls back to\n    * `setTimeout` on browsers that do not support `requestIdleCallback`.\n    *\n    * @namespace\n    * @summary Async interface wrapper around `requestIdleCallback`.\n    */\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */cancel(handle) {\n    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n  }\n\n}; /**\n    * Async interface for enqueuing callbacks that run at microtask timing.\n    *\n    * Note that microtask timing is achieved via a single `MutationObserver`,\n    * and thus callbacks enqueued with this API will all run in a single\n    * batch, and not interleaved with other microtasks such as promises.\n    * Promises are avoided as an implementation choice for the time being\n    * due to Safari bugs that cause Promises to lack microtask guarantees.\n    *\n    * @namespace\n    * @summary Async interface for enqueuing callbacks that run at microtask\n    *   timing.\n    */\nconst microTask = {\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */run(callback) {\n    microtaskNode.textContent = microtaskNodeContent++;\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n\n      microtaskCallbacks[idx] = null;\n    }\n  }\n\n};\nvar async = {\n  timeOut: timeOut,\n  animationFrame: animationFrame,\n  idlePeriod: idlePeriod,\n  microTask: microTask\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ /** @const {!AsyncInterface} */\nconst microtask = microTask; /**\n                              * Element class mixin that provides basic meta-programming for creating one\n                              * or more property accessors (getter/setter pair) that enqueue an async\n                              * (batched) `_propertiesChanged` callback.\n                              *\n                              * For basic usage of this mixin, call `MyClass.createProperties(props)`\n                              * once at class definition time to create property accessors for properties\n                              * named in props, implement `_propertiesChanged` to react as desired to\n                              * property changes, and implement `static get observedAttributes()` and\n                              * include lowercase versions of any property names that should be set from\n                              * attributes. Last, call `this._enableProperties()` in the element's\n                              * `connectedCallback` to enable the accessors.\n                              *\n                              * @mixinFunction\n                              * @polymer\n                              * @summary Element class mixin for reacting to property changes from\n                              *   generated property accessors.\n                              */\nconst PropertiesChanged = dedupingMixin( /**\n                                          * @template T\n                                          * @param {function(new:T)} superClass Class to apply mixin to.\n                                          * @return {function(new:T)} superClass with mixin applied.\n                                          */superClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */class PropertiesChanged extends superClass {\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     */static createProperties(props) {\n      const proto = this.prototype;\n\n      for (let prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    } /**\n       * Returns an attribute name that corresponds to the given property.\n       * The attribute name is the lowercased property name. Override to\n       * customize this mapping.\n       * @param {string} property Property to convert\n       * @return {string} Attribute name corresponding to the given property.\n       *\n       * @protected\n       */\n\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    } /**\n       * Override point to provide a type to which to deserialize a value to\n       * a given property.\n       * @param {string} name Name of property\n       *\n       * @protected\n       */\n\n    static typeForProperty(name) {} //eslint-disable-line no-unused-vars\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     * @override\n     */\n\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n\n      if (!this.hasOwnProperty('__dataHasAccessor')) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n\n        this._definePropertyAccessor(property, readOnly);\n      }\n    } /**\n       * Adds the given `property` to a map matching attribute names\n       * to property names, using `attributeNameForProperty`. This map is\n       * used when deserializing attribute values to properties.\n       *\n       * @param {string} property Name of the property\n       * @override\n       */\n\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty('__dataAttributes')) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n\n      if (!this.__dataAttributes[property]) {\n        const attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n    } /**\n       * Defines a property accessor for the given property.\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created\n       * @return {void}\n       * @override\n       */\n\n    _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */ /** @this {PropertiesChanged} */get() {\n          return this._getProperty(property);\n        },\n\n        /** @this {PropertiesChanged} */set: readOnly ? function () {} : function (value) {\n          this._setProperty(property, value);\n        } /* eslint-enable */\n      });\n    }\n\n    constructor() {\n      super();\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      this.__serializing = false;\n\n      this._initializeProperties();\n    } /**\n       * Lifecycle callback called when properties are enabled via\n       * `_enableProperties`.\n       *\n       * Users may override this function to implement behavior that is\n       * dependent on the element having its property data initialized, e.g.\n       * from defaults (initialized from `constructor`, `_initializeProperties`),\n       * `attributeChangedCallback`, or values propagated from host e.g. via\n       * bindings.  `super.ready()` must be called to ensure the data system\n       * becomes enabled.\n       *\n       * @return {void}\n       * @public\n       * @override\n       */\n\n    ready() {\n      this.__dataReady = true;\n\n      this._flushProperties();\n    } /**\n       * Initializes the local storage for property accessors.\n       *\n       * Provided as an override point for performing any setup work prior\n       * to initializing the property accessor system.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (let p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    } /**\n       * Called at ready time with bag of instance properties that overwrote\n       * accessors when the element upgraded.\n       *\n       * The default implementation sets these properties back into the\n       * setter at ready time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    } /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    } /**\n       * Returns the value for the given property.\n       * @param {string} property Name of property\n       * @return {*} Value for the given property\n       * @protected\n       * @override\n       */\n\n    _getProperty(property) {\n      return this.__data[property];\n    } /* eslint-disable no-unused-vars */ /**\n                                           * Updates the local storage for a property, records the previous value,\n                                           * and adds it to the set of \"pending changes\" that will be passed to the\n                                           * `_propertiesChanged` callback.  This method does not enqueue the\n                                           * `_propertiesChanged` callback.\n                                           *\n                                           * @param {string} property Name of the property\n                                           * @param {*} value Value to set\n                                           * @param {boolean=} ext Not used here; affordance for closure\n                                           * @return {boolean} Returns true if the property changed\n                                           * @protected\n                                           * @override\n                                           */\n\n    _setPendingProperty(property, value, ext) {\n      let old = this.__data[property];\n\n      let changed = this._shouldPropertyChange(property, value, old);\n\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        } // Ensure old is captured from the last turn\n\n\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n\n      return changed;\n    } /* eslint-enable */ /**\n                           * Marks the properties as invalid, and enqueues an async\n                           * `_propertiesChanged` callback.\n                           *\n                           * @return {void}\n                           * @protected\n                           * @override\n                           */\n\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n\n            this._flushProperties();\n          }\n        });\n      }\n    } /**\n       * Call to enable property accessor processing. Before this method is\n       * called accessor values will be set but side effects are\n       * queued. When called, any pending side effects occur immediately.\n       * For elements, generally `connectedCallback` is a normal spot to do so.\n       * It is safe to call this method multiple times as it only turns on\n       * property accessors once.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n\n          this.__dataInstanceProps = null;\n        }\n\n        this.ready();\n      }\n    } /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes. Generally, this method\n       * should not be called in user code.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    _flushProperties() {\n      const props = this.__data;\n      const changedProps = this.__dataPending;\n      const old = this.__dataOld;\n\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n\n        this._propertiesChanged(props, changedProps, old);\n      }\n    } /**\n       * Called in `_flushProperties` to determine if `_propertiesChanged`\n       * should be called. The default implementation returns true if\n       * properties are pending. Override to customize when\n       * `_propertiesChanged` is called.\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {boolean} true if changedProps is truthy\n       * @override\n       */\n\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n      // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    } /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     * @override\n     */\n\n    _shouldPropertyChange(property, value, old) {\n      return (// Strict equality check\n        old !== value && ( // This ensures (old==NaN, value==NaN) always returns false\n        old === old || value === value)\n      );\n    } /**\n       * Implements native Custom Elements `attributeChangedCallback` to\n       * set an attribute value to a property via `_attributeToProperty`.\n       *\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       * @param {?string} namespace Attribute namespace.\n       * @return {void}\n       * @suppress {missingProperties} Super may or may not implement the callback\n       * @override\n       */\n\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    } /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeValue` method to convert the string to\n       * a typed value.\n       *\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {?string} value of the attribute.\n       * @param {*=} type type to deserialize to, defaults to the value\n       * returned from `typeForProperty`\n       * @return {void}\n       * @override\n       */\n\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        const map = this.__dataAttributes;\n        const property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));\n      }\n    } /**\n       * Serializes a property to its associated attribute.\n       *\n       * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect to.\n       * @param {*=} value Property value to refect.\n       * @return {void}\n       * @override\n       */\n\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = arguments.length < 3 ? this[property] : value;\n\n      this._valueToNodeAttribute( /** @type {!HTMLElement} */this, value, attribute || this.constructor.attributeNameForProperty(property));\n\n      this.__serializing = false;\n    } /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeValue` method to convert the typed\n       * value to a string.  If the `_serializeValue` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       * @return {void}\n       * @override\n       */\n\n    _valueToNodeAttribute(node, value, attribute) {\n      const str = this._serializeValue(value);\n\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        node.setAttribute(attribute, str);\n      }\n    } /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * This method is called when setting JS property values to\n       * HTML attributes.  Users may override this method to provide\n       * serialization for custom types.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided\n       * property  value.\n       * @override\n       */\n\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    } /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called when reading HTML attribute values to\n       * JS properties.  Users may override this method to provide\n       * deserialization for custom `type`s. Types for `Boolean`, `String`,\n       * and `Number` convert attributes to the expected types.\n       *\n       * @param {?string} value Value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       * @override\n       */\n\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return value !== null;\n\n        case Number:\n          return Number(value);\n\n        default:\n          return value;\n      }\n    }\n\n  }\n\n  return PropertiesChanged;\n});\nvar propertiesChanged = {\n  PropertiesChanged: PropertiesChanged\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */\nlet caseMap$2 = caseMap$1; // Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\n\nconst nativeProperties = {};\nlet proto = HTMLElement.prototype;\n\nwhile (proto) {\n  let props = Object.getOwnPropertyNames(proto);\n\n  for (let i = 0; i < props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n\n  proto = Object.getPrototypeOf(proto);\n} /**\n   * Used to save the value of a property that will be overridden with\n   * an accessor. If the `model` is a prototype, the values will be saved\n   * in `__dataProto`, and it's up to the user (or downstream mixin) to\n   * decide how/when to set these values back into the accessors.\n   * If `model` is already an instance (it has a `__data` property), then\n   * the value will be set as a pending property, meaning the user should\n   * call `_invalidateProperties` or `_flushProperties` to take effect\n   *\n   * @param {Object} model Prototype or instance\n   * @param {string} property Name of property\n   * @return {void}\n   * @private\n   */\n\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    let value = model[property];\n\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n} /**\n   * Element class mixin that provides basic meta-programming for creating one\n   * or more property accessors (getter/setter pair) that enqueue an async\n   * (batched) `_propertiesChanged` callback.\n   *\n   * For basic usage of this mixin:\n   *\n   * -   Declare attributes to observe via the standard `static get observedAttributes()`. Use\n   *     `dash-case` attribute names to represent `camelCase` property names.\n   * -   Implement the `_propertiesChanged` callback on the class.\n   * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to generate\n   *     property accessors for each observed attribute. This must be called before the first\n   *     instance is created, for example, by calling it before calling `customElements.define`.\n   *     It can also be called lazily from the element's `constructor`, as long as it's guarded so\n   *     that the call is only made once, when the first instance is created.\n   * -   Call `this._enableProperties()` in the element's `connectedCallback` to enable\n   *     the accessors.\n   *\n   * Any `observedAttributes` will automatically be\n   * deserialized via `attributeChangedCallback` and set to the associated\n   * property using `dash-case`-to-`camelCase` convention.\n   *\n   * @mixinFunction\n   * @polymer\n   * @appliesMixin PropertiesChanged\n   * @summary Element class mixin for reacting to property changes from\n   *   generated property accessors.\n   */\n\nconst PropertyAccessors = dedupingMixin(superClass => {\n  /**\n   * @constructor\n   * @extends {superClass}\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */const base = PropertiesChanged(superClass); /**\n                                                  * @polymer\n                                                  * @mixinClass\n                                                  * @implements {Polymer_PropertyAccessors}\n                                                  * @extends {base}\n                                                  * @unrestricted\n                                                  */\n\n  class PropertyAccessors extends base {\n    /**\n     * Generates property accessors for all attributes in the standard\n     * static `observedAttributes` array.\n     *\n     * Attribute names are mapped to property names using the `dash-case` to\n     * `camelCase` convention\n     *\n     * @return {void}\n     */static createPropertiesForAttributes() {\n      let a$ = this.observedAttributes;\n\n      for (let i = 0; i < a$.length; i++) {\n        this.prototype._createPropertyAccessor(caseMap$2.dashToCamelCase(a$[i]));\n      }\n    } /**\n       * Returns an attribute name that corresponds to the given property.\n       * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n       * @param {string} property Property to convert\n       * @return {string} Attribute name corresponding to the given property.\n       *\n       * @protected\n       */\n\n    static attributeNameForProperty(property) {\n      return caseMap$2.camelToDashCase(property);\n    } /**\n       * Overrides PropertiesChanged implementation to initialize values for\n       * accessors created for values that already existed on the element\n       * prototype.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    _initializeProperties() {\n      if (this.__dataProto) {\n        this._initializeProtoProperties(this.__dataProto);\n\n        this.__dataProto = null;\n      }\n\n      super._initializeProperties();\n    } /**\n       * Called at instance time with bag of properties that were overwritten\n       * by accessors on the prototype when accessors were created.\n       *\n       * The default implementation sets these properties back into the\n       * setter at instance time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       */\n\n    _initializeProtoProperties(props) {\n      for (let p in props) {\n        this._setProperty(p, props[p]);\n      }\n    } /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       * @suppress {invalidCasts} Closure can't figure out `this` is infact an element\n       *\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       * @return {void}\n       */\n\n    _ensureAttribute(attribute, value) {\n      const el = /** @type {!HTMLElement} */this;\n\n      if (!el.hasAttribute(attribute)) {\n        this._valueToNodeAttribute(el, value, attribute);\n      }\n    } /**\n       * Overrides PropertiesChanged implemention to serialize objects as JSON.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property value.\n       */\n\n    _serializeValue(value) {\n      /* eslint-disable no-fallthrough */switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return value.toString();\n          } else if (value) {\n            try {\n              return JSON.stringify(value);\n            } catch (x) {\n              return '';\n            }\n          }\n\n        default:\n          return super._serializeValue(value);\n      }\n    } /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       *\n       * @param {?string} value Attribute value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       */\n\n    _deserializeValue(value, type) {\n      /**\n       * @type {*}\n       */let outValue;\n\n      switch (type) {\n        case Object:\n          try {\n            outValue = JSON.parse( /** @type {string} */value);\n          } catch (x) {\n            // allow non-JSON literals like Strings and Numbers\n            outValue = value;\n          }\n\n          break;\n\n        case Array:\n          try {\n            outValue = JSON.parse( /** @type {string} */value);\n          } catch (x) {\n            outValue = null;\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n          }\n\n          break;\n\n        case Date:\n          outValue = isNaN(value) ? String(value) : Number(value);\n          outValue = new Date(outValue);\n          break;\n\n        default:\n          outValue = super._deserializeValue(value, type);\n          break;\n      }\n\n      return outValue;\n    } /* eslint-enable no-fallthrough */ /**\n                                          * Overrides PropertiesChanged implementation to save existing prototype\n                                          * property value so that it can be reset.\n                                          * @param {string} property Name of the property\n                                          * @param {boolean=} readOnly When true, no setter is created\n                                          *\n                                          * When calling on a prototype, any overwritten values are saved in\n                                          * `__dataProto`, and it is up to the subclasser to decide how/when\n                                          * to set those properties back into the accessor.  When calling on an\n                                          * instance, the overwritten value is set via `_setPendingProperty`,\n                                          * and the user should call `_invalidateProperties` or `_flushProperties`\n                                          * for the values to take effect.\n                                          * @protected\n                                          * @return {void}\n                                          */\n\n    _definePropertyAccessor(property, readOnly) {\n      saveAccessorValue(this, property);\n\n      super._definePropertyAccessor(property, readOnly);\n    } /**\n       * Returns true if this library created an accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if an accessor was created\n       */\n\n    _hasAccessor(property) {\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\n    } /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       */\n\n    _isPropertyPending(prop) {\n      return Boolean(this.__dataPending && prop in this.__dataPending);\n    }\n\n  }\n\n  return PropertyAccessors;\n});\nvar propertyAccessors = {\n  PropertyAccessors: PropertyAccessors\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ // 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\n\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\n\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n\n    while (t.attributes.length) {\n      node.setAttribute(t.attributes[0].name, t.attributes[0].value);\n      t.removeAttribute(t.attributes[0].name);\n    }\n  }\n\n  return node;\n}\n\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo); // unwind the stack, returning the indexed node at each level\n\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n} // construct `$` map (from id annotations)\n\n\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n} // install event listeners (from event annotations)\n\n\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n} // push configuration references at configure time\n\n\nfunction applyTemplateContent(inst, node, nodeInfo) {\n  if (nodeInfo.templateInfo) {\n    node._templateInfo = nodeInfo.templateInfo;\n  }\n}\n\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n\n  let handler = function (e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n\n  return handler;\n} /**\n   * Element mixin that provides basic template parsing and stamping, including\n   * the following template-related features for stamped templates:\n   *\n   * - Declarative event listeners (`on-eventname=\"listener\"`)\n   * - Map of node id's to stamped node instances (`this.$.id`)\n   * - Nested template content caching/removal and re-installation (performance\n   *   optimization)\n   *\n   * @mixinFunction\n   * @polymer\n   * @summary Element class mixin that provides basic template parsing and stamping\n   */\n\nconst TemplateStamp = dedupingMixin( /**\n                                      * @template T\n                                      * @param {function(new:T)} superClass Class to apply mixin to.\n                                      * @return {function(new:T)} superClass with mixin applied.\n                                      */superClass => {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */class TemplateStamp extends superClass {\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     */static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        let templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');\n\n        this._parseTemplateContent(template, templateInfo, {\n          parent: null\n        });\n      }\n\n      return template._templateInfo;\n    }\n\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    } /**\n       * Parses template node and adds template and node metadata based on\n       * the current node, and its `childNodes` and `attributes`.\n       *\n       * This method may be overridden to add custom node or template specific\n       * metadata based on this node.\n       *\n       * @param {Node} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted;\n      let element = /** @type {Element} */node;\n\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n\n      if (element.firstChild) {\n        noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;\n      }\n\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n\n      return noted;\n    } /**\n       * Parses template child nodes for the given root node.\n       *\n       * This method also wraps whitelisted legacy template extensions\n       * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n       * wrappers, collapses text nodes, and strips whitespace from the template\n       * if the `templateInfo.stripWhitespace` setting was provided.\n       *\n       * @param {Node} root Root node whose `childNodes` will be parsed\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {void}\n       */\n\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n\n      for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        } // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n\n\n        next = node.nextSibling;\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */n = next;\n\n          while (n && n.nodeType === Node.TEXT_NODE) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          } // optionally strip whitespace\n\n\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n\n        let childInfo = {\n          parentIndex,\n          parentInfo: nodeInfo\n        };\n\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;\n        } // Increment if not removed\n\n\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    } /**\n       * Parses template content for the given nested `<template>`.\n       *\n       * Nested template info is stored as `templateInfo` in the current node's\n       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n       * It will then be the responsibility of the host to set it back to the\n       * template and for users stamping nested templates to use the\n       * `_contentForTemplate` method to retrieve the content for this template\n       * (an optimization to avoid the cost of cloning nested template content).\n       *\n       * @param {HTMLTemplateElement} node Node to parse (a <template>)\n       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n       *   that includes the template `node`\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      let templateInfo = this._parseTemplate(node, outerTemplateInfo);\n\n      let content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();\n      content.appendChild(node.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    } /**\n       * Parses template node attributes and adds node metadata to `nodeInfo`\n       * for nodes of interest.\n       *\n       * @param {Element} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n\n      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n\n      return noted;\n    } /**\n       * Parses a single template node attribute and adds node metadata to\n       * `nodeInfo` for attributes of interest.\n       *\n       * This implementation adds metadata for `on-event=\"handler\"` attributes\n       * and `id` attributes.\n       *\n       * @param {Element} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @param {string} name Attribute name\n       * @param {string} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       */\n\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      } // static id\n      else if (name === 'id') {\n          nodeInfo.id = value;\n          return true;\n        }\n\n      return false;\n    } /**\n       * Returns the `content` document fragment for a given template.\n       *\n       * For nested templates, Polymer performs an optimization to cache nested\n       * template content to avoid the cost of cloning deeply nested templates.\n       * This method retrieves the cached content for a given template.\n       *\n       * @param {HTMLTemplateElement} template Template to retrieve `content` for\n       * @return {DocumentFragment} Content fragment\n       */\n\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;\n      return templateInfo && templateInfo.content || template.content;\n    } /**\n       * Clones the provided template content and returns a document fragment\n       * containing the cloned dom.\n       *\n       * The template is parsed (once and memoized) using this library's\n       * template parsing features, and provides the following value-added\n       * features:\n       * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n       * * Generates an \"id map\" for all nodes with id's under `$` on returned\n       *   document fragment\n       * * Passes template info including `content` back to templates as\n       *   `_templateInfo` (a performance optimization to avoid deep template\n       *   cloning)\n       *\n       * Note that the memoized template parsing process is destructive to the\n       * template: attributes for bindings and declarative event listeners are\n       * removed after being noted in notes, and any nested `<template>.content`\n       * is removed and stored in notes as well.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @return {!StampedTemplate} Cloned template content\n       * @override\n       */\n\n    _stampTemplate(template) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n\n      let templateInfo = this.constructor._parseTemplate(template);\n\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */document.importNode(content, true); // NOTE: ShadyDom optimization indicating there is an insertion point\n\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n\n      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateContent(this, node, info);\n        applyEventListener(this, node, info);\n      }\n\n      dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign\n\n      return dom;\n    } /**\n       * Adds an event listener by method name for the event provided.\n       *\n       * This method generates a handler function that looks up the method\n       * name at handling time.\n       *\n       * @param {!Node} node Node to add listener on\n       * @param {string} eventName Name of event\n       * @param {string} methodName Name of method\n       * @param {*=} context Context the method will be called on (defaults\n       *   to `node`)\n       * @return {Function} Generated handler function\n       * @override\n       */\n\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n\n      this._addEventListenerToNode(node, eventName, handler);\n\n      return handler;\n    } /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {!Node} node Node to add event listener to\n       * @param {string} eventName Name of event\n       * @param {function(!Event):void} handler Listener function to add\n       * @return {void}\n       * @override\n       */\n\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    } /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {!Node} node Node to remove event listener from\n       * @param {string} eventName Name of event\n       * @param {function(!Event):void} handler Listener function to remove\n       * @return {void}\n       * @override\n       */\n\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n\n  }\n\n  return TemplateStamp;\n});\nvar templateStamp = {\n  TemplateStamp: TemplateStamp\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ /** @const {Object} */\nconst CaseMap = caseMap$1; // Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\n\nlet dedupeId$1 = 0; /**\n                     * Property effect types; effects are stored on the prototype using these keys\n                     * @enum {string}\n                     */\nconst TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n}; /** @const {RegExp} */\nconst capitalAttributeRegex = /[A-Z]/; /**\n                                        * @typedef {{\n                                        * name: (string | undefined),\n                                        * structured: (boolean | undefined),\n                                        * wildcard: (boolean | undefined)\n                                        * }}\n                                        */\nlet DataTrigger; //eslint-disable-line no-unused-vars\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\nlet DataEffect; //eslint-disable-line no-unused-vars\n\nlet PropertyEffectsType; //eslint-disable-line no-unused-vars\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\n\nfunction ensureOwnEffectMap(model, type) {\n  let effects = model[type];\n\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n\n    for (let p in effects) {\n      let protoFx = effects[p];\n      let instFx = effects[p] = Array(protoFx.length);\n\n      for (let i = 0; i < protoFx.length; i++) {\n        instFx[i] = protoFx[i];\n      }\n    }\n  }\n\n  return effects;\n} // -- effects ----------------------------------------------\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!PropertyEffectsType} inst The instance with effects to run\n * @param {Object} effects Object map of property-to-Array of effects\n * @param {Object} props Bag of current property changes\n * @param {Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\n\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    let ran = false;\n    let id = dedupeId$1++;\n\n    for (let prop in props) {\n      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {\n        ran = true;\n      }\n    }\n\n    return ran;\n  }\n\n  return false;\n} /**\n   * Runs a list of effects for a given property.\n   *\n   * @param {!PropertyEffectsType} inst The instance with effects to run\n   * @param {Object} effects Object map of property-to-Array of effects\n   * @param {number} dedupeId Counter used for de-duping effects\n   * @param {string} prop Name of changed property\n   * @param {*} props Changed properties\n   * @param {*} oldProps Old properties\n   * @param {boolean=} hasPaths True with `props` contains one or more paths\n   * @param {*=} extraArgs Additional metadata to pass to effect function\n   * @return {boolean} True if an effect ran for this property\n   * @private\n   */\n\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  let ran = false;\n  let rootProperty = hasPaths ? root(prop) : prop;\n  let fxs = effects[rootProperty];\n\n  if (fxs) {\n    for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n\n  return ran;\n} /**\n   * Determines whether a property/path that has changed matches the trigger\n   * criteria for an effect.  A trigger is a descriptor with the following\n   * structure, which matches the descriptors returned from `parseArg`.\n   * e.g. for `foo.bar.*`:\n   * ```\n   * trigger: {\n   *   name: 'a.b',\n   *   structured: true,\n   *   wildcard: true\n   * }\n   * ```\n   * If no trigger is given, the path is deemed to match.\n   *\n   * @param {string} path Path or property that changed\n   * @param {DataTrigger} trigger Descriptor\n   * @return {boolean} Whether the path matched the trigger\n   */\n\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    let triggerPath = trigger.name;\n    return triggerPath == path || trigger.structured && isAncestor(triggerPath, path) || trigger.wildcard && isDescendant(triggerPath, path);\n  } else {\n    return true;\n  }\n} /**\n   * Implements the \"observer\" effect.\n   *\n   * Calls the method with `info.methodName` on the instance, passing the\n   * new and old values.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @return {void}\n   * @private\n   */\n\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  let fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  let changedProp = info.property;\n\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n} /**\n   * Runs \"notify\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * will dispatch path notification events in the case that the property\n   * changed was a path and the root property for that path didn't have a\n   * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n   * `notify: true` to ensure object sub-property notifications were\n   * sent.\n   *\n   * @param {!PropertyEffectsType} inst The instance with effects to run\n   * @param {Object} notifyProps Bag of properties to notify\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @return {void}\n   * @private\n   */\n\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  let fxs = inst[TYPES.NOTIFY];\n  let notified;\n  let id = dedupeId$1++; // Try normal notify effects; if none, fall back to try path notification\n\n  for (let prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  } // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n\n\n  let host;\n\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n} /**\n   * Dispatches {property}-changed events with path information in the detail\n   * object to indicate a sub-path of the property was changed.\n   *\n   * @param {!PropertyEffectsType} inst The element from which to fire the event\n   * @param {string} path The path that was changed\n   * @param {Object} props Bag of current property changes\n   * @return {boolean} Returns true if the path was notified\n   * @private\n   */\n\nfunction notifyPath(inst, path, props) {\n  let rootProperty = root(path);\n\n  if (rootProperty !== path) {\n    let eventName = camelToDashCase(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n\n  return false;\n} /**\n   * Dispatches {property}-changed events to indicate a property (or path)\n   * changed.\n   *\n   * @param {!PropertyEffectsType} inst The element from which to fire the event\n   * @param {string} eventName The name of the event to send ('{property}-changed')\n   * @param {*} value The value of the changed property\n   * @param {string | null | undefined} path If a sub-path of this property changed, the path\n   *   that changed (optional).\n   * @return {void}\n   * @private\n   * @suppress {invalidCasts}\n   */\n\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  let detail = {\n    value: value,\n    queueProperty: true\n  };\n\n  if (path) {\n    detail.path = path;\n  } /** @type {!HTMLElement} */\n\n  inst.dispatchEvent(new CustomEvent(eventName, {\n    detail\n  }));\n} /**\n   * Implements the \"notify\" effect.\n   *\n   * Dispatches a non-bubbling event named `info.eventName` on the instance\n   * with a detail object containing the new `value`.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @return {void}\n   * @private\n   */\n\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  let rootProperty = hasPaths ? root(property) : property;\n  let path = rootProperty != property ? property : null;\n  let value = path ? get(inst, path) : inst.__data[property];\n\n  if (path && value === undefined) {\n    value = props[property]; // specifically for .splices\n  }\n\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n} /**\n   * Handler function for 2-way notification events. Receives context\n   * information captured in the `addNotifyListener` closure from the\n   * `__notifyListeners` metadata.\n   *\n   * Sets the value of the notified property to the host property or path.  If\n   * the event contained path information, translate that path to the host\n   * scope's name for that path first.\n   *\n   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n   * @param {!PropertyEffectsType} inst Host element instance handling the notification event\n   * @param {string} fromProp Child element property that was bound\n   * @param {string} toPath Host property/path that was bound\n   * @param {boolean} negate Whether the binding was negated\n   * @return {void}\n   * @private\n   */\n\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  let value;\n  let detail = /** @type {Object} */event.detail;\n  let fromPath = detail && detail.path;\n\n  if (fromPath) {\n    toPath = translate(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.target[fromProp];\n  }\n\n  value = negate ? !value : value;\n\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n} /**\n   * Implements the \"reflect\" effect.\n   *\n   * Sets the attribute named `info.attrName` to the given property value.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @return {void}\n   * @private\n   */\n\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  let value = inst.__data[property];\n\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);\n  }\n\n  inst._propertyToAttribute(property, info.attrName, value);\n} /**\n   * Runs \"computed\" effects for a set of changed properties.\n   *\n   * This method differs from the generic `runEffects` method in that it\n   * continues to run computed effects based on the output of each pass until\n   * there are no more newly computed properties.  This ensures that all\n   * properties that will be computed by the initial set of changes are\n   * computed before other effects (binding propagation, observers, and notify)\n   * run.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {!Object} changedProps Bag of changed properties\n   * @param {!Object} oldProps Bag of previous values for changed properties\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @return {void}\n   * @private\n   */\n\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  let computeEffects = inst[TYPES.COMPUTE];\n\n  if (computeEffects) {\n    let inputProps = changedProps;\n\n    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n      Object.assign(oldProps, inst.__dataOld);\n      Object.assign(changedProps, inst.__dataPending);\n      inputProps = inst.__dataPending;\n      inst.__dataPending = null;\n    }\n  }\n} /**\n   * Implements the \"computed property\" effect by running the method with the\n   * values of the arguments specified in the `info` object and setting the\n   * return value to the computed property specified.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @return {void}\n   * @private\n   */\n\nfunction runComputedEffect(inst, property, props, oldProps, info) {\n  let result = runMethodEffect(inst, property, props, oldProps, info);\n  let computedProp = info.methodInfo;\n\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n  }\n} /**\n   * Computes path changes based on path links set up using the `linkPaths`\n   * API.\n   *\n   * @param {!PropertyEffectsType} inst The instance whose props are changing\n   * @param {string | !Array<(string|number)>} path Path that has changed\n   * @param {*} value Value of changed path\n   * @return {void}\n   * @private\n   */\n\nfunction computeLinkedPaths(inst, path, value) {\n  let links = inst.__dataLinkedPaths;\n\n  if (links) {\n    let link;\n\n    for (let a in links) {\n      let b = links[a];\n\n      if (isDescendant(a, path)) {\n        link = translate(a, b, path);\n\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if (isDescendant(b, path)) {\n        link = translate(b, a, path);\n\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n} // -- bindings ----------------------------------------------\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\n\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  let /** Binding */binding = {\n    kind,\n    target,\n    parts,\n    literal,\n    isCompound: parts.length !== 1\n  };\n  nodeInfo.bindings.push(binding); // Add listener info to binding metadata\n\n  if (shouldAddListener(binding)) {\n    let {\n      event,\n      negate\n    } = binding.parts[0];\n    binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';\n    binding.listenerNegate = negate;\n  } // Add \"propagate\" property effects to templateInfo\n\n\n  let index = templateInfo.nodeInfoList.length;\n\n  for (let i = 0; i < binding.parts.length; i++) {\n    let part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n} /**\n   * Adds property effects to the given `templateInfo` for the given binding\n   * part.\n   *\n   * @param {Function} constructor Class that `_parseTemplate` is currently\n   *   running on\n   * @param {TemplateInfo} templateInfo Template metadata for current template\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @param {number} index Index into `nodeInfoList` for this node\n   * @return {void}\n   */\n\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n    } else {\n      let dependencies = part.dependencies;\n      let info = {\n        index,\n        binding,\n        part,\n        evaluator: constructor\n      };\n\n      for (let j = 0; j < dependencies.length; j++) {\n        let trigger = dependencies[j];\n\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info,\n          trigger\n        });\n      }\n    }\n  }\n} /**\n   * Implements the \"binding\" (property/path binding) effect.\n   *\n   * Note that binding syntax is overridable via `_parseBindings` and\n   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n   * non-literal parts returned from `_parseBindings`.  However,\n   * there is no support for _path_ bindings via custom binding parts,\n   * as this is specific to Polymer's path binding syntax.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} path Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @param {boolean} hasPaths True with `props` contains one or more paths\n   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n   *   metadata\n   * @return {void}\n   * @private\n   */\n\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  let node = nodeList[info.index];\n  let binding = info.binding;\n  let part = info.part; // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n\n  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    let value = props[path];\n    path = translate(part.source, binding.target, path);\n\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths); // Propagate value to child\n\n\n    applyBindingValue(inst, node, binding, part, value);\n  }\n} /**\n   * Sets the value for an \"binding\" (binding) effect to a node,\n   * either as a property or attribute.\n   *\n   * @param {!PropertyEffectsType} inst The instance owning the binding effect\n   * @param {Node} node Target node for binding\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @param {*} value Value to set\n   * @return {void}\n   * @private\n   */\n\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, binding.target, binding.kind, node);\n  }\n\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);\n  } else {\n    // Property binding\n    let prop = binding.target;\n\n    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n} /**\n   * Transforms an \"binding\" effect value based on compound & negation\n   * effect metadata, as well as handling for special-case properties\n   *\n   * @param {Node} node Node the value will be set to\n   * @param {*} value Value to set\n   * @param {!Binding} binding Binding metadata\n   * @param {!BindingPart} part Binding part metadata\n   * @return {*} Transformed value to set\n   * @private\n   */\n\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    let storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {\n      value = value == undefined ? '' : value;\n    }\n  }\n\n  return value;\n} /**\n   * Returns true if a binding's metadata meets all the requirements to allow\n   * 2-way binding, and therefore a `<property>-changed` event listener should be\n   * added:\n   * - used curly braces\n   * - is a property (not attribute) binding\n   * - is not a textContent binding\n   * - is not compound\n   *\n   * @param {!Binding} binding Binding metadata\n   * @return {boolean} True if 2-way listener should be added\n   * @private\n   */\n\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n} /**\n   * Setup compound binding storage structures, notify listeners, and dataHost\n   * references onto the bound nodeList.\n   *\n   * @param {!PropertyEffectsType} inst Instance that bas been previously bound\n   * @param {TemplateInfo} templateInfo Template metadata\n   * @return {void}\n   * @private\n   */\n\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  let {\n    nodeList,\n    nodeInfoList\n  } = templateInfo;\n\n  if (nodeInfoList.length) {\n    for (let i = 0; i < nodeInfoList.length; i++) {\n      let info = nodeInfoList[i];\n      let node = nodeList[i];\n      let bindings = info.bindings;\n\n      if (bindings) {\n        for (let i = 0; i < bindings.length; i++) {\n          let binding = bindings[i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n\n      node.__dataHost = inst;\n    }\n  }\n} /**\n   * Initializes `__dataCompoundStorage` local storage on a bound node with\n   * initial literal data for compound bindings, and sets the joined\n   * literal parts to the bound property.\n   *\n   * When changes to compound parts occur, they are first set into the compound\n   * storage array for that property, and then the array is joined to result in\n   * the final value set to the property/attribute.\n   *\n   * @param {Node} node Bound node to initialize\n   * @param {Binding} binding Binding metadata\n   * @return {void}\n   * @private\n   */\n\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n    let parts = binding.parts; // Copy literals from parts into storage for this binding\n\n    let literals = new Array(parts.length);\n\n    for (let j = 0; j < parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n\n    let target = binding.target;\n    storage[target] = literals; // Configure properties with their literal parts\n\n    if (binding.literal && binding.kind == 'property') {\n      node[target] = binding.literal;\n    }\n  }\n} /**\n   * Adds a 2-way binding notification event listener to the node specified\n   *\n   * @param {Object} node Child element to add listener to\n   * @param {!PropertyEffectsType} inst Host element instance to handle notification event\n   * @param {Binding} binding Binding metadata\n   * @return {void}\n   * @private\n   */\n\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    let part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function (e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n} // -- for method-based effects (complexObserver & computed) --------------\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {void}\n * @private\n */\n\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);\n  let info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo,\n    dynamicFn\n  };\n\n  for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn,\n        info: info,\n        trigger: arg\n      });\n    }\n  }\n\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn,\n      info: info\n    });\n  }\n} /**\n   * Calls a method with arguments marshaled from properties on the instance\n   * based on the method signature contained in the effect metadata.\n   *\n   * Multi-property observers, computed properties, and inline computing\n   * functions call this function to invoke the method, then use the return\n   * value accordingly.\n   *\n   * @param {!PropertyEffectsType} inst The instance the effect will be run on\n   * @param {string} property Name of property\n   * @param {Object} props Bag of current property changes\n   * @param {Object} oldProps Bag of previous values for changed properties\n   * @param {?} info Effect metadata\n   * @return {*} Returns the return value from the method invocation\n   * @private\n   */\n\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  let context = inst._methodHost || inst;\n  let fn = context[info.methodName];\n\n  if (fn) {\n    let args = marshalArgs(inst.__data, info.args, property, props);\n    return fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\n\nconst emptyArray = []; // Regular expressions used for binding\n\nconst IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nconst NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nconst SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nconst DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nconst STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nconst ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\\\s*' + ')';\nconst ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nconst ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\nconst BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\n\nconst OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nconst CLOSE_BRACKET = '(?:]]|}})';\nconst NEGATE = '(?:(!)\\\\s*)?'; // Group 2\n\nconst EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nconst bindingRegex = new RegExp(EXPRESSION, \"g\"); /**\n                                                   * Create a string from binding parts of all the literal parts\n                                                   *\n                                                   * @param {!Array<BindingPart>} parts All parts to stringify\n                                                   * @return {string} String made from the literal parts\n                                                   */\n\nfunction literalFromParts(parts) {\n  let s = '';\n\n  for (let i = 0; i < parts.length; i++) {\n    let literal = parts[i].literal;\n    s += literal || '';\n  }\n\n  return s;\n} /**\n   * Parses an expression string for a method signature, and returns a metadata\n   * describing the method in terms of `methodName`, `static` (whether all the\n   * arguments are literals), and an array of `args`\n   *\n   * @param {string} expression The expression to parse\n   * @return {?MethodSignature} The method metadata object if a method expression was\n   *   found, otherwise `undefined`\n   * @private\n   */\n\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n\n  if (m) {\n    let methodName = m[1];\n    let sig = {\n      methodName,\n      static: true,\n      args: emptyArray\n    };\n\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n\n  return null;\n} /**\n   * Parses an array of arguments and sets the `args` property of the supplied\n   * signature metadata object. Sets the `static` property to false if any\n   * argument is a non-literal.\n   *\n   * @param {!Array<string>} argList Array of argument names\n   * @param {!MethodSignature} sig Method signature metadata object\n   * @return {!MethodSignature} The updated signature metadata object\n   * @private\n   */\n\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function (rawArg) {\n    let arg = parseArg(rawArg);\n\n    if (!arg.literal) {\n      sig.static = false;\n    }\n\n    return arg;\n  }, this);\n  return sig;\n} /**\n   * Parses an individual argument, and returns an argument metadata object\n   * with the following fields:\n   *\n   *   {\n   *     value: 'prop',        // property/path or literal value\n   *     literal: false,       // whether argument is a literal\n   *     structured: false,    // whether the property is a path\n   *     rootProperty: 'prop', // the root property of the path\n   *     wildcard: false       // whether the argument was a wildcard '.*' path\n   *   }\n   *\n   * @param {string} rawArg The string value of the argument\n   * @return {!MethodArg} Argument metadata object\n   * @private\n   */\n\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  let arg = rawArg.trim() // replace comma entity with comma\n  .replace(/&comma;/g, ',') // repair extra escape sequences; note only commas strictly need\n  // escaping, but we allow any other char to be escaped since its\n  // likely users will do this\n  .replace(/\\\\(.)/g, '\\$1'); // basic argument descriptor\n\n  let a = {\n    name: arg,\n    value: '',\n    literal: false\n  }; // detect literal value (must be String or Number)\n\n  let fc = arg[0];\n\n  if (fc === '-') {\n    fc = arg[1];\n  }\n\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n\n  switch (fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  } // if not literal, look for structured path\n\n\n  if (!a.literal) {\n    a.rootProperty = root(arg); // detect structured path (has dots)\n\n    a.structured = isPath(arg);\n\n    if (a.structured) {\n      a.wildcard = arg.slice(-2) == '.*';\n\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n\n  return a;\n} /**\n   * Gather the argument values for a method specified in the provided array\n   * of argument metadata.\n   *\n   * The `path` and `value` arguments are used to fill in wildcard descriptor\n   * when the method is being called as a result of a path notification.\n   *\n   * @param {Object} data Instance data storage object to read properties from\n   * @param {!Array<!MethodArg>} args Array of argument metadata\n   * @param {string} path Property/path name that triggered the method effect\n   * @param {Object} props Bag of current property changes\n   * @return {Array<*>} Array of argument values\n   * @private\n   */\n\nfunction marshalArgs(data, args, path, props) {\n  let values = [];\n\n  for (let i = 0, l = args.length; i < l; i++) {\n    let arg = args[i];\n    let name = arg.name;\n    let v;\n\n    if (arg.literal) {\n      v = arg.value;\n    } else {\n      if (arg.structured) {\n        v = get(data, name); // when data is not stored e.g. `splices`\n\n        if (v === undefined) {\n          v = props[name];\n        }\n      } else {\n        v = data[name];\n      }\n    }\n\n    if (arg.wildcard) {\n      // Only send the actual path changed info if the change that\n      // caused the observer to run matched the wildcard\n      let baseChanged = name.indexOf(path + '.') === 0;\n      let matches$$1 = path.indexOf(name) === 0 && !baseChanged;\n      values[i] = {\n        path: matches$$1 ? path : name,\n        value: matches$$1 ? props[path] : v,\n        base: v\n      };\n    } else {\n      values[i] = v;\n    }\n  }\n\n  return values;\n} // data api\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!PropertyEffectsType} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\n\nfunction notifySplices(inst, array, path, splices) {\n  let splicesPath = path + '.splices';\n  inst.notifyPath(splicesPath, {\n    indexSplices: splices\n  });\n  inst.notifyPath(path + '.length', array.length); // Null here to allow potentially large splice records to be GC'ed.\n\n  inst.__data[splicesPath] = {\n    indexSplices: null\n  };\n} /**\n   * Creates a splice record and sends an array splice notification for\n   * the described mutation\n   *\n   * Note: this implementation only accepts normalized paths\n   *\n   * @param {!PropertyEffectsType} inst Instance to send notifications to\n   * @param {Array} array The array the mutations occurred on\n   * @param {string} path The path to the array that was mutated\n   * @param {number} index Index at which the array mutation occurred\n   * @param {number} addedCount Number of added items\n   * @param {Array} removed Array of removed items\n   * @return {void}\n   * @private\n   */\n\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n} /**\n   * Returns an upper-cased version of the string.\n   *\n   * @param {string} name String to uppercase\n   * @return {string} Uppercased string\n   * @private\n   */\n\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n} /**\n   * Element class mixin that provides meta-programming for Polymer's template\n   * binding and data observation (collectively, \"property effects\") system.\n   *\n   * This mixin uses provides the following key static methods for adding\n   * property effects to an element class:\n   * - `addPropertyEffect`\n   * - `createPropertyObserver`\n   * - `createMethodObserver`\n   * - `createNotifyingProperty`\n   * - `createReadOnlyProperty`\n   * - `createReflectedProperty`\n   * - `createComputedProperty`\n   * - `bindTemplate`\n   *\n   * Each method creates one or more property accessors, along with metadata\n   * used by this mixin's implementation of `_propertiesChanged` to perform\n   * the property effects.\n   *\n   * Underscored versions of the above methods also exist on the element\n   * prototype for adding property effects on instances at runtime.\n   *\n   * Note that this mixin overrides several `PropertyAccessors` methods, in\n   * many cases to maintain guarantees provided by the Polymer 1.x features;\n   * notably it changes property accessors to be synchronous by default\n   * whereas the default when using `PropertyAccessors` standalone is to be\n   * async by default.\n   *\n   * @mixinFunction\n   * @polymer\n   * @appliesMixin TemplateStamp\n   * @appliesMixin PropertyAccessors\n   * @summary Element class mixin that provides meta-programming for Polymer's\n   * template binding and data observation system.\n   */\n\nconst PropertyEffects = dedupingMixin(superClass => {\n  /**\n   * @constructor\n   * @extends {superClass}\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass)); /**\n                                                                                * @polymer\n                                                                                * @mixinClass\n                                                                                * @implements {Polymer_PropertyEffects}\n                                                                                * @extends {propertyEffectsBase}\n                                                                                * @unrestricted\n                                                                                */\n\n  class PropertyEffects extends propertyEffectsBase {\n    constructor() {\n      super(); /** @type {boolean} */ // Used to identify users of this mixin, ala instanceof\n\n      this.__isPropertyEffectsClient = true; /** @type {number} */ // NOTE: used to track re-entrant calls to `_flushProperties`\n      // path changes dirty check against `__dataTemp` only during one \"turn\"\n      // and are cleared when `__dataCounter` returns to 0.\n\n      this.__dataCounter = 0; /** @type {boolean} */\n      this.__dataClientsReady; /** @type {Array} */\n      this.__dataPendingClients; /** @type {Object} */\n      this.__dataToNotify; /** @type {Object} */\n      this.__dataLinkedPaths; /** @type {boolean} */\n      this.__dataHasPaths; /** @type {Object} */\n      this.__dataCompoundStorage; /** @type {Polymer_PropertyEffects} */\n      this.__dataHost; /** @type {!Object} */\n      this.__dataTemp; /** @type {boolean} */\n      this.__dataClientsInitialized; /** @type {!Object} */\n      this.__data; /** @type {!Object} */\n      this.__dataPending; /** @type {!Object} */\n      this.__dataOld; /** @type {Object} */\n      this.__computeEffects; /** @type {Object} */\n      this.__reflectEffects; /** @type {Object} */\n      this.__notifyEffects; /** @type {Object} */\n      this.__propagateEffects; /** @type {Object} */\n      this.__observeEffects; /** @type {Object} */\n      this.__readOnly; /** @type {!TemplateInfo} */\n      this.__templateInfo;\n    }\n\n    get PROPERTY_EFFECT_TYPES() {\n      return TYPES;\n    } /**\n       * @return {void}\n       */\n\n    _initializeProperties() {\n      super._initializeProperties();\n\n      hostStack.registerHost(this);\n      this.__dataClientsReady = false;\n      this.__dataPendingClients = null;\n      this.__dataToNotify = null;\n      this.__dataLinkedPaths = null;\n      this.__dataHasPaths = false; // May be set on instance prior to upgrade\n\n      this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n      this.__dataHost = this.__dataHost || null;\n      this.__dataTemp = {};\n      this.__dataClientsInitialized = false;\n    } /**\n       * Overrides `PropertyAccessors` implementation to provide a\n       * more efficient implementation of initializing properties from\n       * the prototype on the instance.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the prototype\n       * @return {void}\n       */\n\n    _initializeProtoProperties(props) {\n      this.__data = Object.create(props);\n      this.__dataPending = Object.create(props);\n      this.__dataOld = {};\n    } /**\n       * Overrides `PropertyAccessors` implementation to avoid setting\n       * `_setProperty`'s `shouldNotify: true`.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the instance\n       * @return {void}\n       */\n\n    _initializeInstanceProperties(props) {\n      let readOnly = this[TYPES.READ_ONLY];\n\n      for (let prop in props) {\n        if (!readOnly || !readOnly[prop]) {\n          this.__dataPending = this.__dataPending || {};\n          this.__dataOld = this.__dataOld || {};\n          this.__data[prop] = this.__dataPending[prop] = props[prop];\n        }\n      }\n    } // Prototype setup ----------------------------------------\n    /**\n     * Equivalent to static `addPropertyEffect` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     */\n\n    _addPropertyEffect(property, type, effect) {\n      this._createPropertyAccessor(property, type == TYPES.READ_ONLY); // effects are accumulated into arrays per property based on type\n\n\n      let effects = ensureOwnEffectMap(this, type)[property];\n\n      if (!effects) {\n        effects = this[type][property] = [];\n      }\n\n      effects.push(effect);\n    } /**\n       * Removes the given property effect.\n       *\n       * @param {string} property Property the effect was associated with\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object to remove\n       * @return {void}\n       */\n\n    _removePropertyEffect(property, type, effect) {\n      let effects = ensureOwnEffectMap(this, type)[property];\n      let idx = effects.indexOf(effect);\n\n      if (idx >= 0) {\n        effects.splice(idx, 1);\n      }\n    } /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    _hasPropertyEffect(property, type) {\n      let effects = this[type];\n      return Boolean(effects && effects[property]);\n    } /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    _hasReadOnlyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n    } /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    _hasNotifyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.NOTIFY);\n    } /**\n       * Returns whether the current prototype/instance has a \"reflect to attribute\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    _hasReflectEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.REFLECT);\n    } /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this type\n       * @protected\n       */\n\n    _hasComputedEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.COMPUTE);\n    } // Runtime ----------------------------------------\n    /**\n     * Sets a pending property or path.  If the root property of the path in\n     * question had no accessor, the path is set, otherwise it is enqueued\n     * via `_setPendingProperty`.\n     *\n     * This function isolates relatively expensive functionality necessary\n     * for the public API (`set`, `setProperties`, `notifyPath`, and property\n     * change listeners via {{...}} bindings), such that it is only done\n     * when paths enter the system, and not at every propagation step.  It\n     * also sets a `__dataHasPaths` flag on the instance which is used to\n     * fast-path slower path-matching code in the property effects host paths.\n     *\n     * `path` can be a path string or array of path parts as accepted by the\n     * public API.\n     *\n     * @param {string | !Array<number|string>} path Path to set\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify Set to true if this change should\n     *  cause a property notification event dispatch\n     * @param {boolean=} isPathNotification If the path being set is a path\n     *   notification of an already changed value, as opposed to a request\n     *   to set and notify the change.  In the latter `false` case, a dirty\n     *   check is performed and then the value is set to the path before\n     *   enqueuing the pending property change.\n     * @return {boolean} Returns true if the property/path was enqueued in\n     *   the pending changes bag.\n     * @protected\n     */\n\n    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n      if (isPathNotification || root(Array.isArray(path) ? path[0] : path) !== path) {\n        // Dirty check changes being set to a path against the actual object,\n        // since this is the entry point for paths into the system; from here\n        // the only dirty checks are against the `__dataTemp` cache to prevent\n        // duplicate work in the same turn only. Note, if this was a notification\n        // of a change already set to a path (isPathNotification: true),\n        // we always let the change through and skip the `set` since it was\n        // already dirty checked at the point of entry and the underlying\n        // object has already been updated\n        if (!isPathNotification) {\n          let old = get(this, path);\n          path = /** @type {string} */set(this, path, value); // Use property-accessor's simpler dirty check\n\n          if (!path || !super._shouldPropertyChange(path, value, old)) {\n            return false;\n          }\n        }\n\n        this.__dataHasPaths = true;\n\n        if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {\n          computeLinkedPaths(this, path, value);\n          return true;\n        }\n      } else {\n        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n          return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);\n        } else {\n          this[path] = value;\n        }\n      }\n\n      return false;\n    } /**\n       * Applies a value to a non-Polymer element/node's property.\n       *\n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting `<input>.value` resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information.\n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @param {!Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       * @return {void}\n       * @protected\n       */\n\n    _setUnmanagedPropertyToNode(node, prop, value) {\n      // It is a judgment call that resetting primitives is\n      // \"bad\" and resettings objects is also \"good\"; alternatively we could\n      // implement a whitelist of tag & property values that should never\n      // be reset (e.g. <input>.value && <select>.value)\n      if (value !== node[prop] || typeof value == 'object') {\n        node[prop] = value;\n      }\n    } /**\n       * Overrides the `PropertiesChanged` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChanged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @override\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify True if property should fire notification\n       *   event (applies only for `notify: true` properties)\n       * @return {boolean} Returns true if the property changed\n       */\n\n    _setPendingProperty(property, value, shouldNotify) {\n      let isPath$$1 = this.__dataHasPaths && isPath(property);\n      let prevProps = isPath$$1 ? this.__dataTemp : this.__data;\n\n      if (this._shouldPropertyChange(property, value, prevProps[property])) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        } // Ensure old is captured from the last turn\n\n\n        if (!(property in this.__dataOld)) {\n          this.__dataOld[property] = this.__data[property];\n        } // Paths are stored in temporary cache (cleared at end of turn),\n        // which is used for dirty-checking, all others stored in __data\n\n\n        if (isPath$$1) {\n          this.__dataTemp[property] = value;\n        } else {\n          this.__data[property] = value;\n        } // All changes go into pending property bag, passed to _propertiesChanged\n\n\n        this.__dataPending[property] = value; // Track properties that should notify separately\n\n        if (isPath$$1 || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {\n          this.__dataToNotify = this.__dataToNotify || {};\n          this.__dataToNotify[property] = shouldNotify;\n        }\n\n        return true;\n      }\n\n      return false;\n    } /**\n       * Overrides base implementation to ensure all accessors set `shouldNotify`\n       * to true, for per-property notification tracking.\n       *\n       * @override\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       */\n\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value, true)) {\n        this._invalidateProperties();\n      }\n    } /**\n       * Overrides `PropertyAccessor`'s default async queuing of\n       * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       * @return {void}\n       */\n\n    _invalidateProperties() {\n      if (this.__dataReady) {\n        this._flushProperties();\n      }\n    } /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @param {Object} client PropertyEffects client to enqueue\n       * @return {void}\n       * @protected\n       */\n\n    _enqueueClient(client) {\n      this.__dataPendingClients = this.__dataPendingClients || [];\n\n      if (client !== this) {\n        this.__dataPendingClients.push(client);\n      }\n    } /**\n       * Overrides superclass implementation.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    _flushProperties() {\n      this.__dataCounter++;\n\n      super._flushProperties();\n\n      this.__dataCounter--;\n    } /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    _flushClients() {\n      if (!this.__dataClientsReady) {\n        this.__dataClientsReady = true;\n\n        this._readyClients(); // Override point where accessors are turned on; importantly,\n        // this is after clients have fully readied, providing a guarantee\n        // that any property effects occur only after all clients are ready.\n\n\n        this.__dataReady = true;\n      } else {\n        this.__enableOrFlushClients();\n      }\n    } // NOTE: We ensure clients either enable or flush as appropriate. This\n    // handles two corner cases:\n    // (1) clients flush properly when connected/enabled before the host\n    // enables; e.g.\n    //   (a) Templatize stamps with no properties and does not flush and\n    //   (b) the instance is inserted into dom and\n    //   (c) then the instance flushes.\n    // (2) clients enable properly when not connected/enabled when the host\n    // flushes; e.g.\n    //   (a) a template is runtime stamped and not yet connected/enabled\n    //   (b) a host sets a property, causing stamped dom to flush\n    //   (c) the stamped dom enables.\n\n\n    __enableOrFlushClients() {\n      let clients = this.__dataPendingClients;\n\n      if (clients) {\n        this.__dataPendingClients = null;\n\n        for (let i = 0; i < clients.length; i++) {\n          let client = clients[i];\n\n          if (!client.__dataEnabled) {\n            client._enableProperties();\n          } else if (client.__dataPending) {\n            client._flushProperties();\n          }\n        }\n      }\n    } /**\n       * Perform any initial setup on client dom. Called before the first\n       * `_flushProperties` call on client dom and before any element\n       * observers are called.\n       *\n       * @return {void}\n       * @protected\n       */\n\n    _readyClients() {\n      this.__enableOrFlushClients();\n    } /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * Property names must be simple properties, not paths.  Batched\n       * path propagation is not supported.\n       *\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       * @param {boolean=} setReadOnly When true, any private values set in\n       *   `props` will be set. By default, `setProperties` will not set\n       *   `readOnly: true` root properties.\n       * @return {void}\n       * @public\n       */\n\n    setProperties(props, setReadOnly) {\n      for (let path in props) {\n        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n          //TODO(kschaaf): explicitly disallow paths in setProperty?\n          // wildcard observers currently only pass the first changed path\n          // in the `info` object, and you could do some odd things batching\n          // paths, e.g. {'foo.bar': {...}, 'foo': null}\n          this._setPendingPropertyOrPath(path, props[path], true);\n        }\n      }\n\n      this._invalidateProperties();\n    } /**\n       * Overrides `PropertyAccessors` so that property accessor\n       * side effects are not enabled until after client dom is fully ready.\n       * Also calls `_flushClients` callback to ensure client dom is enabled\n       * that was not enabled as a result of flushing properties.\n       *\n       * @override\n       * @return {void}\n       */\n\n    ready() {\n      // It is important that `super.ready()` is not called here as it\n      // immediately turns on accessors. Instead, we wait until `readyClients`\n      // to enable accessors to provide a guarantee that clients are ready\n      // before processing any accessors side effects.\n      this._flushProperties(); // If no data was pending, `_flushProperties` will not `flushClients`\n      // so ensure this is done.\n\n\n      if (!this.__dataClientsReady) {\n        this._flushClients();\n      } // Before ready, client notifications do not trigger _flushProperties.\n      // Therefore a flush is necessary here if data has been set.\n\n\n      if (this.__dataPending) {\n        this._flushProperties();\n      }\n    } /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       */\n\n    _propertiesChanged(currentProps, changedProps, oldProps) {\n      // ----------------------------\n      // let c = Object.getOwnPropertyNames(changedProps || {});\n      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n      // if (window.debug) { debugger; }\n      // ----------------------------\n      let hasPaths = this.__dataHasPaths;\n      this.__dataHasPaths = false; // Compute properties\n\n      runComputedEffects(this, changedProps, oldProps, hasPaths); // Clear notify properties prior to possible reentry (propagate, observe),\n      // but after computing effects have a chance to add to them\n\n      let notifyProps = this.__dataToNotify;\n      this.__dataToNotify = null; // Propagate properties to clients\n\n      this._propagatePropertyChanges(changedProps, oldProps, hasPaths); // Flush clients\n\n\n      this._flushClients(); // Reflect properties\n\n\n      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths); // Observe properties\n\n      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths); // Notify properties to host\n\n      if (notifyProps) {\n        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n      } // Clear temporary cache at end of turn\n\n\n      if (this.__dataCounter == 1) {\n        this.__dataTemp = {};\n      } // ----------------------------\n      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n      // ----------------------------\n\n    } /**\n       * Called to propagate any property changes to stamped template nodes\n       * managed by this element.\n       *\n       * @param {Object} changedProps Bag of changed properties\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {void}\n       * @protected\n       */\n\n    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n      if (this[TYPES.PROPAGATE]) {\n        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n      }\n\n      let templateInfo = this.__templateInfo;\n\n      while (templateInfo) {\n        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n        templateInfo = templateInfo.nextTemplateInfo;\n      }\n    } /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @return {void}\n       * @public\n       */\n\n    linkPaths(to, from) {\n      to = normalize(to);\n      from = normalize(from);\n      this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n      this.__dataLinkedPaths[to] = from;\n    } /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @return {void}\n       * @public\n       */\n\n    unlinkPaths(path) {\n      path = normalize(path);\n\n      if (this.__dataLinkedPaths) {\n        delete this.__dataLinkedPaths[path];\n      }\n    } /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, object: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       * @return {void}\n       * @public\n      */\n\n    notifySplices(path, splices) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */get(this, path, info);\n      notifySplices(this, array, info.path, splices);\n    } /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n\n    get(path, root$$1) {\n      return get(root$$1 || this, path);\n    } /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @return {void}\n       * @public\n      */\n\n    set(path, value, root$$1) {\n      if (root$$1) {\n        set(root$$1, path, value);\n      } else {\n        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {\n          if (this._setPendingPropertyOrPath(path, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n      }\n    } /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n\n    push(path, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array}*/get(this, path, info);\n      let len = array.length;\n      let ret = array.push(...items);\n\n      if (items.length) {\n        notifySplice(this, array, info.path, len, items.length, []);\n      }\n\n      return ret;\n    } /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n\n    pop(path) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */get(this, path, info);\n      let hadLength = Boolean(array.length);\n      let ret = array.pop();\n\n      if (hadLength) {\n        notifySplice(this, array, info.path, array.length, 0, [ret]);\n      }\n\n      return ret;\n    } /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {Array} Array of removed items.\n       * @public\n       */\n\n    splice(path, start, deleteCount, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */get(this, path, info); // Normalize fancy native splice handling of crazy start values\n\n      if (start < 0) {\n        start = array.length - Math.floor(-start);\n      } else if (start) {\n        start = Math.floor(start);\n      } // array.splice does different things based on the number of arguments\n      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n      // do different things. In the former, the whole array is cleared. In the\n      // latter, no items are removed.\n      // This means that we need to detect whether 1. one of the arguments\n      // is actually passed in and then 2. determine how many arguments\n      // we should pass on to the native array.splice\n      //\n\n\n      let ret; // Omit any additional arguments if they were not passed in\n\n      if (arguments.length === 2) {\n        ret = array.splice(start); // Either start was undefined and the others were defined, but in this\n        // case we can safely pass on all arguments\n        //\n        // Note: this includes the case where none of the arguments were passed in,\n        // e.g. this.splice('array'). However, if both start and deleteCount\n        // are undefined, array.splice will not modify the array (as expected)\n      } else {\n        ret = array.splice(start, deleteCount, ...items);\n      } // At the end, check whether any items were passed in (e.g. insertions)\n      // or if the return array contains items (e.g. deletions).\n      // Only notify if items were added or deleted.\n\n\n      if (items.length || ret.length) {\n        notifySplice(this, array, info.path, start, items.length, ret);\n      }\n\n      return ret;\n    } /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n\n    shift(path) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */get(this, path, info);\n      let hadLength = Boolean(array.length);\n      let ret = array.shift();\n\n      if (hadLength) {\n        notifySplice(this, array, info.path, 0, 0, [ret]);\n      }\n\n      return ret;\n    } /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n\n    unshift(path, ...items) {\n      let info = {\n        path: ''\n      };\n      let array = /** @type {Array} */get(this, path, info);\n      let ret = array.unshift(...items);\n\n      if (items.length) {\n        notifySplice(this, array, info.path, 0, items.length, []);\n      }\n\n      return ret;\n    } /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @return {void}\n       * @public\n      */\n\n    notifyPath(path, value) {\n      /** @type {string} */let propPath;\n\n      if (arguments.length == 1) {\n        // Get value if not supplied\n        let info = {\n          path: ''\n        };\n        value = get(this, path, info);\n        propPath = info.path;\n      } else if (Array.isArray(path)) {\n        // Normalize path if needed\n        propPath = normalize(path);\n      } else {\n        propPath = /** @type{string} */path;\n      }\n\n      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n        this._invalidateProperties();\n      }\n    } /**\n       * Equivalent to static `createReadOnlyProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @return {void}\n       * @protected\n       */\n\n    _createReadOnlyProperty(property, protectedSetter) {\n      this._addPropertyEffect(property, TYPES.READ_ONLY);\n\n      if (protectedSetter) {\n        this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {\n          this._setProperty(property, value);\n        };\n      }\n    } /**\n       * Equivalent to static `createPropertyObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @param {string|function(*,*)} method Function or name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    _createPropertyObserver(property, method, dynamicFn) {\n      let info = {\n        property,\n        method,\n        dynamicFn: Boolean(dynamicFn)\n      };\n\n      this._addPropertyEffect(property, TYPES.OBSERVE, {\n        fn: runObserverEffect,\n        info,\n        trigger: {\n          name: property\n        }\n      });\n\n      if (dynamicFn) {\n        this._addPropertyEffect( /** @type {string} */method, TYPES.OBSERVE, {\n          fn: runObserverEffect,\n          info,\n          trigger: {\n            name: method\n          }\n        });\n      }\n    } /**\n       * Equivalent to static `createMethodObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    _createMethodObserver(expression, dynamicFn) {\n      let sig = parseMethod(expression);\n\n      if (!sig) {\n        throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n      }\n\n      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n    } /**\n       * Equivalent to static `createNotifyingProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    _createNotifyingProperty(property) {\n      this._addPropertyEffect(property, TYPES.NOTIFY, {\n        fn: runNotifyEffect,\n        info: {\n          eventName: CaseMap.camelToDashCase(property) + '-changed',\n          property: property\n        }\n      });\n    } /**\n       * Equivalent to static `createReflectedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    _createReflectedProperty(property) {\n      let attr = this.constructor.attributeNameForProperty(property);\n\n      if (attr[0] === '-') {\n        console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n      } else {\n        this._addPropertyEffect(property, TYPES.REFLECT, {\n          fn: runReflectEffect,\n          info: {\n            attrName: attr\n          }\n        });\n      }\n    } /**\n       * Equivalent to static `createComputedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    _createComputedProperty(property, expression, dynamicFn) {\n      let sig = parseMethod(expression);\n\n      if (!sig) {\n        throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n      }\n\n      createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n    } // -- static class methods ------------\n    /**\n     * Ensures an accessor exists for the specified property, and adds\n     * to a list of \"property effects\" that will run when the accessor for\n     * the specified property is set.  Effects are grouped by \"type\", which\n     * roughly corresponds to a phase in effect processing.  The effect\n     * metadata should be in the following form:\n     *\n     *     {\n     *       fn: effectFunction, // Reference to function to call to perform effect\n     *       info: { ... }       // Effect metadata passed to function\n     *       trigger: {          // Optional triggering metadata; if not provided\n     *         name: string      // the property is treated as a wildcard\n     *         structured: boolean\n     *         wildcard: boolean\n     *       }\n     *     }\n     *\n     * Effects are called from `_propertiesChanged` in the following order by\n     * type:\n     *\n     * 1. COMPUTE\n     * 2. PROPAGATE\n     * 3. REFLECT\n     * 4. OBSERVE\n     * 5. NOTIFY\n     *\n     * Effect functions are called with the following signature:\n     *\n     *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n     *\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     */\n\n    static addPropertyEffect(property, type, effect) {\n      this.prototype._addPropertyEffect(property, type, effect);\n    } /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string|function(*,*)} method Function or name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    static createPropertyObserver(property, method, dynamicFn) {\n      this.prototype._createPropertyObserver(property, method, dynamicFn);\n    } /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal JavaScript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       * @return {void}\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       */\n\n    static createMethodObserver(expression, dynamicFn) {\n      this.prototype._createMethodObserver(expression, dynamicFn);\n    } /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    static createNotifyingProperty(property) {\n      this.prototype._createNotifyingProperty(property);\n    } /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @return {void}\n       * @protected\n       */\n\n    static createReadOnlyProperty(property, protectedSetter) {\n      this.prototype._createReadOnlyProperty(property, protectedSetter);\n    } /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n\n    static createReflectedProperty(property) {\n      this.prototype._createReflectedProperty(property);\n    } /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal JavaScript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n       *   method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n\n    static createComputedProperty(property, expression, dynamicFn) {\n      this.prototype._createComputedProperty(property, expression, dynamicFn);\n    } /**\n       * Parses the provided template to ensure binding effects are created\n       * for them, and then ensures property accessors are created for any\n       * dependent properties in the template.  Binding effects for bound\n       * templates are stored in a linked list on the instance so that\n       * templates can be efficiently stamped and unstamped.\n       *\n       * @param {!HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @return {!TemplateInfo} Template metadata object\n       * @protected\n       */\n\n    static bindTemplate(template) {\n      return this.prototype._bindTemplate(template);\n    } // -- binding ----------------------------------------------\n    /**\n     * Equivalent to static `bindTemplate` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * This method may be called on the prototype (for prototypical template\n     * binding, to avoid creating accessors every instance) once per prototype,\n     * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n     * create and link an instance of the template metadata associated with a\n     * particular stamping.\n     *\n     * @param {!HTMLTemplateElement} template Template containing binding\n     *   bindings\n     * @param {boolean=} instanceBinding When false (default), performs\n     *   \"prototypical\" binding of the template and overwrites any previously\n     *   bound template for the class. When true (as passed from\n     *   `_stampTemplate`), the template info is instanced and linked into\n     *   the list of bound templates.\n     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n     *   this is an instance of the prototypical template info\n     * @protected\n     */\n\n    _bindTemplate(template, instanceBinding) {\n      let templateInfo = this.constructor._parseTemplate(template);\n\n      let wasPreBound = this.__templateInfo == templateInfo; // Optimization: since this is called twice for proto-bound templates,\n      // don't attempt to recreate accessors if this template was pre-bound\n\n      if (!wasPreBound) {\n        for (let prop in templateInfo.propertyEffects) {\n          this._createPropertyAccessor(prop);\n        }\n      }\n\n      if (instanceBinding) {\n        // For instance-time binding, create instance of template metadata\n        // and link into list of templates if necessary\n        templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);\n        templateInfo.wasPreBound = wasPreBound;\n\n        if (!wasPreBound && this.__templateInfo) {\n          let last = this.__templateInfoLast || this.__templateInfo;\n          this.__templateInfoLast = last.nextTemplateInfo = templateInfo;\n          templateInfo.previousTemplateInfo = last;\n          return templateInfo;\n        }\n      }\n\n      return this.__templateInfo = templateInfo;\n    } /**\n       * Adds a property effect to the given template metadata, which is run\n       * at the \"propagate\" stage of `_propertiesChanged` when the template\n       * has been bound to the element via `_bindTemplate`.\n       *\n       * The `effect` object should match the format in `_addPropertyEffect`.\n       *\n       * @param {Object} templateInfo Template metadata to add effect to\n       * @param {string} prop Property that should trigger the effect\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       */\n\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n      hostProps[prop] = true;\n      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n      let propEffects = effects[prop] = effects[prop] || [];\n      propEffects.push(effect);\n    } /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * This method may be called more than once; however note that due to\n       * `shadycss` polyfill limitations, only styles from templates prepared\n       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n       * to the shadow root and support CSS custom properties), and note that\n       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n       * any styles required by in runtime-stamped templates must be included\n       * in the main element template.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @return {!StampedTemplate} Cloned template content\n       * @override\n       * @protected\n       */\n\n    _stampTemplate(template) {\n      // Ensures that created dom is `_enqueueClient`'d to this element so\n      // that it can be flushed on next call to `_flushProperties`\n      hostStack.beginHosting(this);\n\n      let dom = super._stampTemplate(template);\n\n      hostStack.endHosting(this);\n\n      let templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true); // Add template-instance-specific data to instanced templateInfo\n\n\n      templateInfo.nodeList = dom.nodeList; // Capture child nodes to allow unstamping of non-prototypical templates\n\n      if (!templateInfo.wasPreBound) {\n        let nodes = templateInfo.childNodes = [];\n\n        for (let n = dom.firstChild; n; n = n.nextSibling) {\n          nodes.push(n);\n        }\n      }\n\n      dom.templateInfo = templateInfo; // Setup compound storage, 2-way listeners, and dataHost for bindings\n\n      setupBindings(this, templateInfo); // Flush properties into template nodes if already booted\n\n      if (this.__dataReady) {\n        runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);\n      }\n\n      return dom;\n    } /**\n       * Removes and unbinds the nodes previously contained in the provided\n       * DocumentFragment returned from `_stampTemplate`.\n       *\n       * @param {!StampedTemplate} dom DocumentFragment previously returned\n       *   from `_stampTemplate` associated with the nodes to be removed\n       * @return {void}\n       * @protected\n       */\n\n    _removeBoundDom(dom) {\n      // Unlink template info\n      let templateInfo = dom.templateInfo;\n\n      if (templateInfo.previousTemplateInfo) {\n        templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;\n      }\n\n      if (templateInfo.nextTemplateInfo) {\n        templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;\n      }\n\n      if (this.__templateInfoLast == templateInfo) {\n        this.__templateInfoLast = templateInfo.previousTemplateInfo;\n      }\n\n      templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null; // Remove stamped nodes\n\n      let nodes = templateInfo.childNodes;\n\n      for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        node.parentNode.removeChild(node);\n      }\n    } /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);\n\n      if (node.nodeType === Node.TEXT_NODE) {\n        let parts = this._parseBindings(node.textContent, templateInfo);\n\n        if (parts) {\n          // Initialize the textContent with any literal parts\n          // NOTE: default to a space here so the textNode remains; some browsers\n          // (IE) omit an empty textNode following cloneNode/importNode.\n          node.textContent = literalFromParts(parts) || ' ';\n          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n          noted = true;\n        }\n      }\n\n      return noted;\n    } /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from attributes.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @override\n       * @param {Element} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @param {string} name Attribute name\n       * @param {string} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      let parts = this._parseBindings(value, templateInfo);\n\n      if (parts) {\n        // Attribute or property\n        let origName = name;\n        let kind = 'property'; // The only way we see a capital letter here is if the attr has\n        // a capital letter in it per spec. In this case, to make sure\n        // this binding works, we go ahead and make the binding to the attribute.\n\n        if (capitalAttributeRegex.test(name)) {\n          kind = 'attribute';\n        } else if (name[name.length - 1] == '$') {\n          name = name.slice(0, -1);\n          kind = 'attribute';\n        } // Initialize attribute bindings with any literal parts\n\n\n        let literal = literalFromParts(parts);\n\n        if (literal && kind == 'attribute') {\n          node.setAttribute(name, literal);\n        } // Clear attribute before removing, since IE won't allow removing\n        // `value` attribute if it previously had a value (can't\n        // unconditionally set '' before removing since attributes with `$`\n        // can't be set using setAttribute)\n\n\n        if (node.localName === 'input' && origName === 'value') {\n          node.setAttribute(origName, '');\n        } // Remove annotation\n\n\n        node.removeAttribute(origName); // Case hackery: attributes are lower-case, but bind targets\n        // (properties) are case sensitive. Gambit is to map dash-case to\n        // camel-case: `foo-bar` becomes `fooBar`.\n        // Attribute bindings are excepted.\n\n        if (kind === 'property') {\n          name = dashToCamelCase(name);\n        }\n\n        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n        return true;\n      } else {\n        return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);\n      }\n    } /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * binding the properties that a nested template depends on to the template\n       * as `_host_<property>`.\n       *\n       * @override\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n      let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo); // Merge host props into outer template and add bindings\n\n\n      let hostProps = nodeInfo.templateInfo.hostProps;\n      let mode = '{';\n\n      for (let source in hostProps) {\n        let parts = [{\n          mode,\n          source,\n          dependencies: [source]\n        }];\n        addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n      }\n\n      return noted;\n    } /**\n       * Called to parse text in a template (either attribute values or\n       * textContent) into binding metadata.\n       *\n       * Any overrides of this method should return an array of binding part\n       * metadata  representing one or more bindings found in the provided text\n       * and any \"literal\" text in between.  Any non-literal parts will be passed\n       * to `_evaluateBinding` when any dependencies change.  The only required\n       * fields of each \"part\" in the returned array are as follows:\n       *\n       * - `dependencies` - Array containing trigger metadata for each property\n       *   that should trigger the binding to update\n       * - `literal` - String containing text if the part represents a literal;\n       *   in this case no `dependencies` are needed\n       *\n       * Additional metadata for use by `_evaluateBinding` may be provided in\n       * each part object as needed.\n       *\n       * The default implementation handles the following types of bindings\n       * (one or more may be intermixed with literal strings):\n       * - Property binding: `[[prop]]`\n       * - Path binding: `[[object.prop]]`\n       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n       * - Two-way property or path bindings (supports negation):\n       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n       * - Inline computed method (supports negation):\n       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n       *\n       * The default implementation uses a regular expression for best\n       * performance. However, the regular expression uses a white-list of\n       * allowed characters in a data-binding, which causes problems for\n       * data-bindings that do use characters not in this white-list.\n       *\n       * Instead of updating the white-list with all allowed characters,\n       * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n       * that uses a state machine instead. This state machine is able to handle\n       * all characters. However, it is slightly less performant, therefore we\n       * extracted it into a separate optional mixin.\n       *\n       * @param {string} text Text to parse from attribute or textContent\n       * @param {Object} templateInfo Current template metadata\n       * @return {Array<!BindingPart>} Array of binding part metadata\n       * @protected\n       */\n\n    static _parseBindings(text, templateInfo) {\n      let parts = [];\n      let lastIndex = 0;\n      let m; // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n      // Regex matches:\n      //        Iteration 1:  Iteration 2:\n      // m[1]: '{{'          '[['\n      // m[2]: ''            '!'\n      // m[3]: 'prop'        'compute(foo,bar)'\n\n      while ((m = bindingRegex.exec(text)) !== null) {\n        // Add literal part\n        if (m.index > lastIndex) {\n          parts.push({\n            literal: text.slice(lastIndex, m.index)\n          });\n        } // Add binding part\n\n\n        let mode = m[1][0];\n        let negate = Boolean(m[2]);\n        let source = m[3].trim();\n        let customEvent = false,\n            notifyEvent = '',\n            colon = -1;\n\n        if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n          notifyEvent = source.substring(colon + 2);\n          source = source.substring(0, colon);\n          customEvent = true;\n        }\n\n        let signature = parseMethod(source);\n        let dependencies = [];\n\n        if (signature) {\n          // Inline computed function\n          let {\n            args,\n            methodName\n          } = signature;\n\n          for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n\n            if (!arg.literal) {\n              dependencies.push(arg);\n            }\n          }\n\n          let dynamicFns = templateInfo.dynamicFns;\n\n          if (dynamicFns && dynamicFns[methodName] || signature.static) {\n            dependencies.push(methodName);\n            signature.dynamicFn = true;\n          }\n        } else {\n          // Property or path\n          dependencies.push(source);\n        }\n\n        parts.push({\n          source,\n          mode,\n          negate,\n          customEvent,\n          signature,\n          dependencies,\n          event: notifyEvent\n        });\n        lastIndex = bindingRegex.lastIndex;\n      } // Add a final literal part\n\n\n      if (lastIndex && lastIndex < text.length) {\n        let literal = text.substring(lastIndex);\n\n        if (literal) {\n          parts.push({\n            literal: literal\n          });\n        }\n      }\n\n      if (parts.length) {\n        return parts;\n      } else {\n        return null;\n      }\n    } /**\n       * Called to evaluate a previously parsed binding part based on a set of\n       * one or more changed dependencies.\n       *\n       * @param {this} inst Element that should be used as scope for\n       *   binding dependencies\n       * @param {BindingPart} part Binding part metadata\n       * @param {string} path Property/path that triggered this effect\n       * @param {Object} props Bag of current property changes\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {*} Value the binding part evaluated to\n       * @protected\n       */\n\n    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n      let value;\n\n      if (part.signature) {\n        value = runMethodEffect(inst, path, props, oldProps, part.signature);\n      } else if (path != part.source) {\n        value = get(inst, part.source);\n      } else {\n        if (hasPaths && isPath(path)) {\n          value = get(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n\n      if (part.negate) {\n        value = !value;\n      }\n\n      return value;\n    }\n\n  } // make a typing for closure :P\n\n\n  PropertyEffectsType = PropertyEffects;\n  return PropertyEffects;\n}); /**\n     * Helper api for enqueuing client dom created by a host element.\n     *\n     * By default elements are flushed via `_flushProperties` when\n     * `connectedCallback` is called. Elements attach their client dom to\n     * themselves at `ready` time which results from this first flush.\n     * This provides an ordering guarantee that the client dom an element\n     * creates is flushed before the element itself (i.e. client `ready`\n     * fires before host `ready`).\n     *\n     * However, if `_flushProperties` is called *before* an element is connected,\n     * as for example `Templatize` does, this ordering guarantee cannot be\n     * satisfied because no elements are connected. (Note: Bound elements that\n     * receive data do become enqueued clients and are properly ordered but\n     * unbound elements are not.)\n     *\n     * To maintain the desired \"client before host\" ordering guarantee for this\n     * case we rely on the \"host stack. Client nodes registers themselves with\n     * the creating host element when created. This ensures that all client dom\n     * is readied in the proper order, maintaining the desired guarantee.\n     *\n     * @private\n     */\n\nclass HostStack {\n  constructor() {\n    this.stack = [];\n  } /**\n     * @param {*} inst Instance to add to hostStack\n     * @return {void}\n     */\n\n  registerHost(inst) {\n    if (this.stack.length) {\n      let host = this.stack[this.stack.length - 1];\n\n      host._enqueueClient(inst);\n    }\n  } /**\n     * @param {*} inst Instance to begin hosting\n     * @return {void}\n     */\n\n  beginHosting(inst) {\n    this.stack.push(inst);\n  } /**\n     * @param {*} inst Instance to end hosting\n     * @return {void}\n     */\n\n  endHosting(inst) {\n    let stackLen = this.stack.length;\n\n    if (stackLen && this.stack[stackLen - 1] == inst) {\n      this.stack.pop();\n    }\n  }\n\n}\n\nconst hostStack = new HostStack();\nvar propertyEffects = {\n  PropertyEffects: PropertyEffects\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ /**\n       * Creates a copy of `props` with each property normalized such that\n       * upgraded it is an object with at least a type property { type: Type}.\n       *\n       * @param {Object} props Properties to normalize\n       * @return {Object} Copy of input `props` with normalized properties that\n       * are in the form {type: Type}\n       * @private\n       */\n\nfunction normalizeProperties(props) {\n  const output = {};\n\n  for (let p in props) {\n    const o = props[p];\n    output[p] = typeof o === 'function' ? {\n      type: o\n    } : o;\n  }\n\n  return output;\n} /**\n   * Mixin that provides a minimal starting point to using the PropertiesChanged\n   * mixin by providing a mechanism to declare properties in a static\n   * getter (e.g. static get properties() { return { foo: String } }). Changes\n   * are reported via the `_propertiesChanged` method.\n   *\n   * This mixin provides no specific support for rendering. Users are expected\n   * to create a ShadowRoot and put content into it and update it in whatever\n   * way makes sense. This can be done in reaction to properties changing by\n   * implementing `_propertiesChanged`.\n   *\n   * @mixinFunction\n   * @polymer\n   * @appliesMixin PropertiesChanged\n   * @summary Mixin that provides a minimal starting point for using\n   * the PropertiesChanged mixin by providing a declarative `properties` object.\n   */\n\nconst PropertiesMixin = dedupingMixin(superClass => {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @private\n   */const base = PropertiesChanged(superClass); /**\n                                                  * Returns the super class constructor for the given class, if it is an\n                                                  * instance of the PropertiesMixin.\n                                                  *\n                                                  * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor\n                                                  * @return {?PropertiesMixinConstructor} Super class constructor\n                                                  */\n\n  function superPropertiesClass(constructor) {\n    const superCtor = Object.getPrototypeOf(constructor); // Note, the `PropertiesMixin` class below only refers to the class\n    // generated by this call to the mixin; the instanceof test only works\n    // because the mixin is deduped and guaranteed only to apply once, hence\n    // all constructors in a proto chain will see the same `PropertiesMixin`\n\n    return superCtor.prototype instanceof PropertiesMixin ? /** @type {!PropertiesMixinConstructor} */superCtor : null;\n  } /**\n     * Returns a memoized version of the `properties` object for the\n     * given class. Properties not in object format are converted to at\n     * least {type}.\n     *\n     * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor\n     * @return {Object} Memoized properties object\n     */\n\n  function ownProperties(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {\n      let props = null;\n\n      if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor)) && constructor.properties) {\n        props = normalizeProperties(constructor.properties);\n      }\n\n      constructor.__ownProperties = props;\n    }\n\n    return constructor.__ownProperties;\n  } /**\n     * @polymer\n     * @mixinClass\n     * @extends {base}\n     * @implements {Polymer_PropertiesMixin}\n     * @unrestricted\n     */\n\n  class PropertiesMixin extends base {\n    /**\n     * Implements standard custom elements getter to observes the attributes\n     * listed in `properties`.\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     */static get observedAttributes() {\n      const props = this._properties;\n      return props ? Object.keys(props).map(p => this.attributeNameForProperty(p)) : [];\n    } /**\n       * Finalizes an element definition, including ensuring any super classes\n       * are also finalized. This includes ensuring property\n       * accessors exist on the element prototype. This method calls\n       * `_finalizeClass` to finalize each constructor in the prototype chain.\n       * @return {void}\n       */\n\n    static finalize() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {\n        const superCtor = superPropertiesClass( /** @type {!PropertiesMixinConstructor} */this);\n\n        if (superCtor) {\n          superCtor.finalize();\n        }\n\n        this.__finalized = true;\n\n        this._finalizeClass();\n      }\n    } /**\n       * Finalize an element class. This includes ensuring property\n       * accessors exist on the element prototype. This method is called by\n       * `finalize` and finalizes the class constructor.\n       *\n       * @protected\n       */\n\n    static _finalizeClass() {\n      const props = ownProperties( /** @type {!PropertiesMixinConstructor} */this);\n\n      if (props) {\n        this.createProperties(props);\n      }\n    } /**\n       * Returns a memoized version of all properties, including those inherited\n       * from super classes. Properties not in object format are converted to\n       * at least {type}.\n       *\n       * @return {Object} Object containing properties for this class\n       * @protected\n       */\n\n    static get _properties() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {\n        const superCtor = superPropertiesClass( /** @type {!PropertiesMixinConstructor} */this);\n        this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties( /** @type {PropertiesMixinConstructor} */this));\n      }\n\n      return this.__properties;\n    } /**\n       * Overrides `PropertiesChanged` method to return type specified in the\n       * static `properties` object for the given property.\n       * @param {string} name Name of property\n       * @return {*} Type to which to deserialize attribute\n       *\n       * @protected\n       */\n\n    static typeForProperty(name) {\n      const info = this._properties[name];\n      return info && info.type;\n    } /**\n       * Overrides `PropertiesChanged` method and adds a call to\n       * `finalize` which lazily configures the element's property accessors.\n       * @override\n       * @return {void}\n       */\n\n    _initializeProperties() {\n      this.constructor.finalize();\n\n      super._initializeProperties();\n    } /**\n       * Called when the element is added to a document.\n       * Calls `_enableProperties` to turn on property system from\n       * `PropertiesChanged`.\n       * @suppress {missingProperties} Super may or may not implement the callback\n       * @return {void}\n       * @override\n       */\n\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      this._enableProperties();\n    } /**\n       * Called when the element is removed from a document\n       * @suppress {missingProperties} Super may or may not implement the callback\n       * @return {void}\n       * @override\n       */\n\n    disconnectedCallback() {\n      if (super.disconnectedCallback) {\n        super.disconnectedCallback();\n      }\n    }\n\n  }\n\n  return PropertiesMixin;\n});\nvar propertiesMixin = {\n  PropertiesMixin: PropertiesMixin\n};\nconst bundledImportMeta = { ...import.meta,\n  url: new URL('../node_modules/%40polymer/polymer/lib/mixins/element-mixin.js', import.meta.url).href\n};\nconst ElementMixin = dedupingMixin(base => {\n  /**\n   * @constructor\n   * @extends {base}\n   * @implements {Polymer_PropertyEffects}\n   * @implements {Polymer_PropertiesMixin}\n   * @private\n   */const polymerElementBase = PropertiesMixin(PropertyEffects(base)); /**\n                                                                         * Returns a list of properties with default values.\n                                                                         * This list is created as an optimization since it is a subset of\n                                                                         * the list returned from `_properties`.\n                                                                         * This list is used in `_initializeProperties` to set property defaults.\n                                                                         *\n                                                                         * @param {PolymerElementConstructor} constructor Element class\n                                                                         * @return {PolymerElementProperties} Flattened properties for this class\n                                                                         *   that have default values\n                                                                         * @private\n                                                                         */\n\n  function propertyDefaults(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {\n      constructor.__propertyDefaults = null;\n      let props = constructor._properties;\n\n      for (let p in props) {\n        let info = props[p];\n\n        if ('value' in info) {\n          constructor.__propertyDefaults = constructor.__propertyDefaults || {};\n          constructor.__propertyDefaults[p] = info;\n        }\n      }\n    }\n\n    return constructor.__propertyDefaults;\n  } /**\n     * Returns a memoized version of the the `observers` array.\n     * @param {PolymerElementConstructor} constructor Element class\n     * @return {Array} Array containing own observers for the given class\n     * @protected\n     */\n\n  function ownObservers(constructor) {\n    if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {\n      constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ? /** @type {PolymerElementConstructor} */constructor.observers : null;\n    }\n\n    return constructor.__ownObservers;\n  } /**\n     * Creates effects for a property.\n     *\n     * Note, once a property has been set to\n     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`\n     * these values may not be changed. For example, a subclass cannot\n     * alter these settings. However, additional `observers` may be added\n     * by subclasses.\n     *\n     * The info object should may contain property metadata as follows:\n     *\n     * * `type`: {function} type to which an attribute matching the property\n     * is deserialized. Note the property is camel-cased from a dash-cased\n     * attribute. For example, 'foo-bar' attribute is deserialized to a\n     * property named 'fooBar'.\n     *\n     * * `readOnly`: {boolean} creates a readOnly property and\n     * makes a private setter for the private of the form '_setFoo' for a\n     * property 'foo',\n     *\n     * * `computed`: {string} creates a computed property. A computed property\n     * also automatically is set to `readOnly: true`. The value is calculated\n     * by running a method and arguments parsed from the given string. For\n     * example 'compute(foo)' will compute a given property when the\n     * 'foo' property changes by executing the 'compute' method. This method\n     * must return the computed value.\n     *\n     * * `reflectToAttribute`: {boolean} If true, the property value is reflected\n     * to an attribute of the same name. Note, the attribute is dash-cased\n     * so a property named 'fooBar' is reflected as 'foo-bar'.\n     *\n     * * `notify`: {boolean} sends a non-bubbling notification event when\n     * the property changes. For example, a property named 'foo' sends an\n     * event named 'foo-changed' with `event.detail` set to the value of\n     * the property.\n     *\n     * * observer: {string} name of a method that runs when the property\n     * changes. The arguments of the method are (value, previousValue).\n     *\n     * Note: Users may want control over modifying property\n     * effects via subclassing. For example, a user might want to make a\n     * reflectToAttribute property not do so in a subclass. We've chosen to\n     * disable this because it leads to additional complication.\n     * For example, a readOnly effect generates a special setter. If a subclass\n     * disables the effect, the setter would fail unexpectedly.\n     * Based on feedback, we may want to try to make effects more malleable\n     * and/or provide an advanced api for manipulating them.\n     * Also consider adding warnings when an effect cannot be changed.\n     *\n     * @param {!PolymerElement} proto Element class prototype to add accessors\n     *   and effects to\n     * @param {string} name Name of the property.\n     * @param {Object} info Info object from which to create property effects.\n     * Supported keys:\n     * @param {Object} allProps Flattened map of all properties defined in this\n     *   element (including inherited properties)\n     * @return {void}\n     * @private\n     */\n\n  function createPropertyFromConfig(proto, name, info, allProps) {\n    // computed forces readOnly...\n    if (info.computed) {\n      info.readOnly = true;\n    } // Note, since all computed properties are readOnly, this prevents\n    // adding additional computed property effects (which leads to a confusing\n    // setup where multiple triggers for setting a property)\n    // While we do have `hasComputedEffect` this is set on the property's\n    // dependencies rather than itself.\n\n\n    if (info.computed && !proto._hasReadOnlyEffect(name)) {\n      proto._createComputedProperty(name, info.computed, allProps);\n    }\n\n    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {\n      proto._createReadOnlyProperty(name, !info.computed);\n    }\n\n    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {\n      proto._createReflectedProperty(name);\n    }\n\n    if (info.notify && !proto._hasNotifyEffect(name)) {\n      proto._createNotifyingProperty(name);\n    } // always add observer\n\n\n    if (info.observer) {\n      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);\n    } // always create the mapping from attribute back to property for deserialization.\n\n\n    proto._addPropertyToAttributeMap(name);\n  } /**\n     * Process all style elements in the element template. Styles with the\n     * `include` attribute are processed such that any styles in\n     * the associated \"style modules\" are included in the element template.\n     * @param {PolymerElementConstructor} klass Element class\n     * @param {!HTMLTemplateElement} template Template to process\n     * @param {string} is Name of element\n     * @param {string} baseURI Base URI for element\n     * @private\n     */\n\n  function processElementStyles(klass, template, is, baseURI) {\n    const templateStyles = template.content.querySelectorAll('style');\n    const stylesWithImports = stylesFromTemplate(template); // insert styles from <link rel=\"import\" type=\"css\"> at the top of the template\n\n    const linkedStyles = stylesFromModuleImports(is);\n    const firstTemplateChild = template.content.firstElementChild;\n\n    for (let idx = 0; idx < linkedStyles.length; idx++) {\n      let s = linkedStyles[idx];\n      s.textContent = klass._processStyleText(s.textContent, baseURI);\n      template.content.insertBefore(s, firstTemplateChild);\n    } // keep track of the last \"concrete\" style in the template we have encountered\n\n\n    let templateStyleIndex = 0; // ensure all gathered styles are actually in this template.\n\n    for (let i = 0; i < stylesWithImports.length; i++) {\n      let s = stylesWithImports[i];\n      let templateStyle = templateStyles[templateStyleIndex]; // if the style is not in this template, it's been \"included\" and\n      // we put a clone of it in the template before the style that included it\n\n      if (templateStyle !== s) {\n        s = s.cloneNode(true);\n        templateStyle.parentNode.insertBefore(s, templateStyle);\n      } else {\n        templateStyleIndex++;\n      }\n\n      s.textContent = klass._processStyleText(s.textContent, baseURI);\n    }\n\n    if (window.ShadyCSS) {\n      window.ShadyCSS.prepareTemplate(template, is);\n    }\n  } /**\n     * @polymer\n     * @mixinClass\n     * @unrestricted\n     * @implements {Polymer_ElementMixin}\n     */\n\n  class PolymerElement extends polymerElementBase {\n    /**\n     * Override of PropertiesMixin _finalizeClass to create observers and\n     * find the template.\n     * @return {void}\n     * @protected\n     * @override\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     */static _finalizeClass() {\n      super._finalizeClass();\n\n      if (this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && this.is) {\n        register(this.prototype);\n      }\n\n      const observers = ownObservers(this);\n\n      if (observers) {\n        this.createObservers(observers, this._properties);\n      } // note: create \"working\" template that is finalized at instance time\n\n\n      let template = /** @type {PolymerElementConstructor} */this.template;\n\n      if (template) {\n        if (typeof template === 'string') {\n          console.error('template getter must return HTMLTemplateElement');\n          template = null;\n        } else {\n          template = template.cloneNode(true);\n        }\n      }\n\n      this.prototype._template = template;\n    } /**\n       * Override of PropertiesChanged createProperties to create accessors\n       * and property effects for all of the properties.\n       * @return {void}\n       * @protected\n       * @override\n       */\n\n    static createProperties(props) {\n      for (let p in props) {\n        createPropertyFromConfig(this.prototype, p, props[p], props);\n      }\n    } /**\n       * Creates observers for the given `observers` array.\n       * Leverages `PropertyEffects` to create observers.\n       * @param {Object} observers Array of observer descriptors for\n       *   this class\n       * @param {Object} dynamicFns Object containing keys for any properties\n       *   that are functions and should trigger the effect when the function\n       *   reference is changed\n       * @return {void}\n       * @protected\n       */\n\n    static createObservers(observers, dynamicFns) {\n      const proto = this.prototype;\n\n      for (let i = 0; i < observers.length; i++) {\n        proto._createMethodObserver(observers[i], dynamicFns);\n      }\n    } /**\n       * Returns the template that will be stamped into this element's shadow root.\n       *\n       * If a `static get is()` getter is defined, the default implementation\n       * will return the first `<template>` in a `dom-module` whose `id`\n       * matches this element's `is`.\n       *\n       * Users may override this getter to return an arbitrary template\n       * (in which case the `is` getter is unnecessary). The template returned\n       * must be an `HTMLTemplateElement`.\n       *\n       * Note that when subclassing, if the super class overrode the default\n       * implementation and the subclass would like to provide an alternate\n       * template via a `dom-module`, it should override this getter and\n       * return `DomModule.import(this.is, 'template')`.\n       *\n       * If a subclass would like to modify the super class template, it should\n       * clone it rather than modify it in place.  If the getter does expensive\n       * work such as cloning/modifying a template, it should memoize the\n       * template for maximum performance:\n       *\n       *   let memoizedTemplate;\n       *   class MySubClass extends MySuperClass {\n       *     static get template() {\n       *       if (!memoizedTemplate) {\n       *         memoizedTemplate = super.template.cloneNode(true);\n       *         let subContent = document.createElement('div');\n       *         subContent.textContent = 'This came from MySubClass';\n       *         memoizedTemplate.content.appendChild(subContent);\n       *       }\n       *       return memoizedTemplate;\n       *     }\n       *   }\n       *\n       * @return {HTMLTemplateElement|string} Template to be stamped\n       */\n\n    static get template() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {\n        this._template = DomModule && DomModule.import( /** @type {PolymerElementConstructor}*/this.is, 'template') || // note: implemented so a subclass can retrieve the super\n        // template; call the super impl this way so that `this` points\n        // to the superclass.\n        Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.template;\n      }\n\n      return this._template;\n    } /**\n       * Path matching the url from which the element was imported.\n       *\n       * This path is used to resolve url's in template style cssText.\n       * The `importPath` property is also set on element instances and can be\n       * used to create bindings relative to the import path.\n       *\n       * For elements defined in ES modules, users should implement\n       * `static get importMeta() { return import.meta; }`, and the default\n       * implementation of `importPath` will  return `import.meta.url`'s path.\n       * For elements defined in HTML imports, this getter will return the path\n       * to the document containing a `dom-module` element matching this\n       * element's static `is` property.\n       *\n       * Note, this path should contain a trailing `/`.\n       *\n       * @return {string} The import path for this element class\n       * @suppress {missingProperties}\n       */\n\n    static get importPath() {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {\n        const meta = this.importMeta;\n\n        if (meta) {\n          this._importPath = pathFromUrl(meta.url);\n        } else {\n          const module = DomModule && DomModule.import( /** @type {PolymerElementConstructor} */this.is);\n          this._importPath = module && module.assetpath || Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.importPath;\n        }\n      }\n\n      return this._importPath;\n    }\n\n    constructor() {\n      super(); /** @type {HTMLTemplateElement} */\n      this._template; /** @type {string} */\n      this._importPath; /** @type {string} */\n      this.rootPath; /** @type {string} */\n      this.importPath; /** @type {StampedTemplate | HTMLElement | ShadowRoot} */\n      this.root; /** @type {!Object<string, !Element>} */\n      this.$;\n    } /**\n       * Overrides the default `PropertyAccessors` to ensure class\n       * metaprogramming related to property accessors and effects has\n       * completed (calls `finalize`).\n       *\n       * It also initializes any property defaults provided via `value` in\n       * `properties` metadata.\n       *\n       * @return {void}\n       * @override\n       * @suppress {invalidCasts}\n       */\n\n    _initializeProperties() {\n      instanceCount++;\n      this.constructor.finalize(); // note: finalize template when we have access to `localName` to\n      // avoid dependence on `is` for polyfilling styling.\n\n      this.constructor._finalizeTemplate( /** @type {!HTMLElement} */this.localName);\n\n      super._initializeProperties(); // set path defaults\n\n\n      this.rootPath = rootPath;\n      this.importPath = this.constructor.importPath; // apply property defaults...\n\n      let p$ = propertyDefaults(this.constructor);\n\n      if (!p$) {\n        return;\n      }\n\n      for (let p in p$) {\n        let info = p$[p]; // Don't set default value if there is already an own property, which\n        // happens when a `properties` property with default but no effects had\n        // a property set (e.g. bound) by its host before upgrade\n\n        if (!this.hasOwnProperty(p)) {\n          let value = typeof info.value == 'function' ? info.value.call(this) : info.value; // Set via `_setProperty` if there is an accessor, to enable\n          // initializing readOnly property defaults\n\n          if (this._hasAccessor(p)) {\n            this._setPendingProperty(p, value, true);\n          } else {\n            this[p] = value;\n          }\n        }\n      }\n    } /**\n       * Gather style text for a style element in the template.\n       *\n       * @param {string} cssText Text containing styling to process\n       * @param {string} baseURI Base URI to rebase CSS paths against\n       * @return {string} The processed CSS text\n       * @protected\n       */\n\n    static _processStyleText(cssText, baseURI) {\n      return resolveCss(cssText, baseURI);\n    } /**\n      * Configures an element `proto` to function with a given `template`.\n      * The element name `is` and extends `ext` must be specified for ShadyCSS\n      * style scoping.\n      *\n      * @param {string} is Tag name (or type extension name) for this element\n      * @return {void}\n      * @protected\n      */\n\n    static _finalizeTemplate(is) {\n      /** @const {HTMLTemplateElement} */const template = this.prototype._template;\n\n      if (template && !template.__polymerFinalized) {\n        template.__polymerFinalized = true;\n        const importPath = this.importPath;\n        const baseURI = importPath ? resolveUrl(importPath) : ''; // e.g. support `include=\"module-name\"`, and ShadyCSS\n\n        processElementStyles(this, template, is, baseURI);\n\n        this.prototype._bindTemplate(template);\n      }\n    } /**\n       * Provides a default implementation of the standard Custom Elements\n       * `connectedCallback`.\n       *\n       * The default implementation enables the property effects system and\n       * flushes any pending properties, and updates shimmed CSS properties\n       * when using the ShadyCSS scoping/custom properties polyfill.\n       *\n       * @suppress {missingProperties, invalidCasts} Super may or may not implement the callback\n       * @return {void}\n       */\n\n    connectedCallback() {\n      if (window.ShadyCSS && this._template) {\n        window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);\n      }\n\n      super.connectedCallback();\n    } /**\n       * Stamps the element template.\n       *\n       * @return {void}\n       * @override\n       */\n\n    ready() {\n      if (this._template) {\n        this.root = this._stampTemplate(this._template);\n        this.$ = this.root.$;\n      }\n\n      super.ready();\n    } /**\n       * Implements `PropertyEffects`'s `_readyClients` call. Attaches\n       * element dom by calling `_attachDom` with the dom stamped from the\n       * element's template via `_stampTemplate`. Note that this allows\n       * client dom to be attached to the element prior to any observers\n       * running.\n       *\n       * @return {void}\n       * @override\n       */\n\n    _readyClients() {\n      if (this._template) {\n        this.root = this._attachDom( /** @type {StampedTemplate} */this.root);\n      } // The super._readyClients here sets the clients initialized flag.\n      // We must wait to do this until after client dom is created/attached\n      // so that this flag can be checked to prevent notifications fired\n      // during this process from being handled before clients are ready.\n\n\n      super._readyClients();\n    } /**\n       * Attaches an element's stamped dom to itself. By default,\n       * this method creates a `shadowRoot` and adds the dom to it.\n       * However, this method may be overridden to allow an element\n       * to put its dom in another location.\n       *\n       * @throws {Error}\n       * @suppress {missingReturn}\n       * @param {StampedTemplate} dom to attach to the element.\n       * @return {ShadowRoot} node to which the dom has been attached.\n       */\n\n    _attachDom(dom) {\n      if (this.attachShadow) {\n        if (dom) {\n          if (!this.shadowRoot) {\n            this.attachShadow({\n              mode: 'open'\n            });\n          }\n\n          this.shadowRoot.appendChild(dom);\n          return this.shadowRoot;\n        }\n\n        return null;\n      } else {\n        throw new Error('ShadowDOM not available. ' + // TODO(sorvell): move to compile-time conditional when supported\n        'PolymerElement can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\\` before \\`ready\\`.');\n      }\n    } /**\n       * When using the ShadyCSS scoping and custom property shim, causes all\n       * shimmed styles in this element (and its subtree) to be updated\n       * based on current custom property values.\n       *\n       * The optional parameter overrides inline custom property styles with an\n       * object of properties where the keys are CSS properties, and the values\n       * are strings.\n       *\n       * Example: `this.updateStyles({'--color': 'blue'})`\n       *\n       * These properties are retained unless a value of `null` is set.\n       *\n       * Note: This function does not support updating CSS mixins.\n       * You can not dynamically change the value of an `@apply`.\n       *\n       * @param {Object=} properties Bag of custom property key/values to\n       *   apply to this element.\n       * @return {void}\n       * @suppress {invalidCasts}\n       */\n\n    updateStyles(properties) {\n      if (window.ShadyCSS) {\n        window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);\n      }\n    } /**\n       * Rewrites a given URL relative to a base URL. The base URL defaults to\n       * the original location of the document containing the `dom-module` for\n       * this element. This method will return the same URL before and after\n       * bundling.\n       *\n       * Note that this function performs no resolution for URLs that start\n       * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose\n       * URL resolution, use `window.URL`.\n       *\n       * @param {string} url URL to resolve.\n       * @param {string=} base Optional base URL to resolve against, defaults\n       * to the element's `importPath`\n       * @return {string} Rewritten URL relative to base\n       */\n\n    resolveUrl(url, base) {\n      if (!base && this.importPath) {\n        base = resolveUrl(this.importPath);\n      }\n\n      return resolveUrl(url, base);\n    } /**\n       * Overrides `PropertyAccessors` to add map of dynamic functions on\n       * template info, for consumption by `PropertyEffects` template binding\n       * code. This map determines which method templates should have accessors\n       * created for them.\n       *\n       * @override\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       */\n\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;\n      return super._parseTemplateContent(template, templateInfo, nodeInfo);\n    }\n\n  }\n\n  return PolymerElement;\n}); /**\n     * Provides basic tracking of element definitions (registrations) and\n     * instance counts.\n     *\n     * @summary Provides basic tracking of element definitions (registrations) and\n     * instance counts.\n     */\n`TODO(modulizer): A namespace named Polymer.telemetry was\ndeclared here. The surrounding comments should be reviewed,\nand this string can then be deleted`; /**\n                                       * Total number of Polymer element instances created.\n                                       * @type {number}\n                                       */\nlet instanceCount = 0; /**\n                               * Array of Polymer element classes that have been finalized.\n                               * @type {Array<PolymerElement>}\n                               */\nconst registrations = []; /**\n                                  * @param {!PolymerElementConstructor} prototype Element prototype to log\n                                  * @this {this}\n                                  * @private\n                                  */\n\nfunction _regLog(prototype) {\n  console.log('[' + prototype.is + ']: registered');\n} /**\n   * Registers a class prototype for telemetry purposes.\n   * @param {HTMLElement} prototype Element prototype to register\n   * @this {this}\n   * @protected\n   */\n\nfunction register(prototype) {\n  registrations.push(prototype);\n  undefined && _regLog(prototype);\n} /**\n   * Logs all elements registered with an `is` to the console.\n   * @public\n   * @this {this}\n   */\n\nfunction dumpRegistrations() {\n  registrations.forEach(_regLog);\n} /**\n   * When using the ShadyCSS scoping and custom property shim, causes all\n   * shimmed `styles` (via `custom-style`) in the document (and its subtree)\n   * to be updated based on current custom property values.\n   *\n   * The optional parameter overrides inline custom property styles with an\n   * object of properties where the keys are CSS properties, and the values\n   * are strings.\n   *\n   * Example: `updateStyles({'--color': 'blue'})`\n   *\n   * These properties are retained unless a value of `null` is set.\n   *\n   * @param {Object=} props Bag of custom property key/values to\n   *   apply to the document.\n   * @return {void}\n   */\n\nconst updateStyles = function (props) {\n  if (window.ShadyCSS) {\n    window.ShadyCSS.styleDocument(props);\n  }\n};\n\nvar elementMixin = {\n  ElementMixin: ElementMixin,\n\n  get instanceCount() {\n    return instanceCount;\n  },\n\n  registrations: registrations,\n  register: register,\n  dumpRegistrations: dumpRegistrations,\n  updateStyles: updateStyles\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ /**\n       * Class representing a static string value which can be used to filter\n       * strings by asseting that they have been created via this class. The\n       * `value` property returns the string passed to the constructor.\n       */\n\nclass LiteralString {\n  constructor(string) {\n    /** @type {string} */this.value = string.toString();\n  } /**\n     * @return {string} LiteralString string value\n     * @override\n     */\n\n  toString() {\n    return this.value;\n  }\n\n} /**\n   * @param {*} value Object to stringify into HTML\n   * @return {string} HTML stringified form of `obj`\n   */\n\nfunction literalValue(value) {\n  if (value instanceof LiteralString) {\n    return (/** @type {!LiteralString} */value.value\n    );\n  } else {\n    throw new Error(`non-literal value passed to Polymer's htmlLiteral function: ${value}`);\n  }\n} /**\n   * @param {*} value Object to stringify into HTML\n   * @return {string} HTML stringified form of `obj`\n   */\n\nfunction htmlValue(value) {\n  if (value instanceof HTMLTemplateElement) {\n    return (/** @type {!HTMLTemplateElement } */value.innerHTML\n    );\n  } else if (value instanceof LiteralString) {\n    return literalValue(value);\n  } else {\n    throw new Error(`non-template value passed to Polymer's html function: ${value}`);\n  }\n} /**\n   * A template literal tag that creates an HTML <template> element from the\n   * contents of the string.\n   *\n   * This allows you to write a Polymer Template in JavaScript.\n   *\n   * Templates can be composed by interpolating `HTMLTemplateElement`s in\n   * expressions in the JavaScript template literal. The nested template's\n   * `innerHTML` is included in the containing template.  The only other\n   * values allowed in expressions are those returned from `htmlLiteral`\n   * which ensures only literal values from JS source ever reach the HTML, to\n   * guard against XSS risks.\n   *\n   * All other values are disallowed in expressions to help prevent XSS\n   * attacks; however, `htmlLiteral` can be used to compose static\n   * string values into templates. This is useful to compose strings into\n   * places that do not accept html, like the css text of a `style`\n   * element.\n   *\n   * Example:\n   *\n   *     static get template() {\n   *       return html`\n   *         <style>:host{ content:\"...\" }</style>\n   *         <div class=\"shadowed\">${this.partialTemplate}</div>\n   *         ${super.template}\n   *       `;\n   *     }\n   *     static get partialTemplate() { return html`<span>Partial!</span>`; }\n   *\n   * @param {!ITemplateArray} strings Constant parts of tagged template literal\n   * @param {...*} values Variable parts of tagged template literal\n   * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement\n   */\n\nconst html = function html(strings, ...values) {\n  const template = /** @type {!HTMLTemplateElement} */document.createElement('template');\n  template.innerHTML = values.reduce((acc, v, idx) => acc + htmlValue(v) + strings[idx + 1], strings[0]);\n  return template;\n}; /**\n    * An html literal tag that can be used with `html` to compose.\n    * a literal string.\n    *\n    * Example:\n    *\n    *     static get template() {\n    *       return html`\n    *         <style>\n    *           :host { display: block; }\n    *           ${this.styleTemplate()}\n    *         </style>\n    *         <div class=\"shadowed\">${staticValue}</div>\n    *         ${super.template}\n    *       `;\n    *     }\n    *     static get styleTemplate() {\n    *        return htmlLiteral`.shadowed { background: gray; }`;\n    *     }\n    *\n    * @param {!ITemplateArray} strings Constant parts of tagged template literal\n    * @param {...*} values Variable parts of tagged template literal\n    * @return {!LiteralString} Constructed literal string\n    */\n\nconst htmlLiteral = function (strings, ...values) {\n  return new LiteralString(values.reduce((acc, v, idx) => acc + literalValue(v) + strings[idx + 1], strings[0]));\n};\n\nvar htmlTag = {\n  html: html,\n  htmlLiteral: htmlLiteral\n}; /**\n   @license\n   Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n   This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n   The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n   The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n   Code distributed by Google as part of the polymer project is also\n   subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n   */ /**\n       * Base class that provides the core API for Polymer's meta-programming\n       * features including template stamping, data-binding, attribute deserialization,\n       * and property change observation.\n       *\n       * @customElement\n       * @polymer\n       * @constructor\n       * @implements {Polymer_ElementMixin}\n       * @extends HTMLElement\n       * @appliesMixin ElementMixin\n       * @summary Custom element base class that provides the core API for Polymer's\n       *   key meta-programming features including template stamping, data-binding,\n       *   attribute deserialization, and property change observation\n       */\nconst PolymerElement = ElementMixin(HTMLElement);\nvar polymerElement = {\n  PolymerElement: PolymerElement,\n  html: html\n};\n\nfunction truthy(val) {\n  if (/^\\s*(true|1|on|yes|y)\\s*$/i.test(val)) {\n    return true;\n  }\n\n  if (/^\\s*(false|0|off|no|n)\\s*$/i.test(val)) {\n    return false;\n  }\n\n  return null;\n} /**\n   * `polymer-element`\n   * Sample element\n   *\n   * @customElement\n   * @polymer\n   * @demo demo/index.html\n   */\n\nclass Answer extends PolymerElement {\n  static get template() {\n    return html`\n            <style>\n                :host {\n                    display: flex;\n                    width: 29%;\n                    flex-basis: 300px;\n                }\n                .answer-caption {\n                    display: inline-block;\n                    vertical-align: middle;\n                }\n                @media (min-width: 600px) {\n                    .answer-wrapper {\n                        display: block;\n                        flex-wrap: wrap;\n                        align-items: center;\n                        justify-content: space-between;\n                    }\n                    .question-preview .answer-wrapper,\n                    .q-footer {\n                        padding: 0 3rem;\n                    }\n                    .test-btn-wrap .answer-wrapper {\n                        padding: 0;\n                    }\n                    .answer-wrapper .question-answer {\n                        display: block;\n                        width: 100%;\n                        min-height: 1px;\n                        align-items: center;\n                        position: relative;\n                    }\n                }\n                @media (max-width: 575.98px) {\n                    .answer-wrapper .question-answer {\n                        width: 100%;\n                    }\n                    .question-preview {\n                        margin-top: 0;\n                    }\n                    .question-preview .question-question p {\n                        line-height: 1.2;\n                    }\n                    .test-btn-wrap {\n                        width: 100%;\n                        margin-left: 0;\n                    }\n                    .test-btn button {\n                        width: 80%;\n                        margin: 10px 10%;\n                    }\n                    .question-preview {\n                        padding: 1rem 1rem;\n                        border-radius: 0;\n                        border-left: none;\n                        border-right: none;\n                    }\n                    .text-answer input {\n                        width: 100%;\n                        margin-left: 0;\n                    }\n                }\n                .answer-wrapper {\n                    justify-content: space-between;\n                    width: 100%;\n                }\n                .answer-wrapper .question-answer {\n                    display: block;\n                    align-items: center;\n                    position: relative;\n                    border: 1px solid rgba(0, 0, 0, 0.1);\n                    border-radius: 0.25rem;\n                    background-color: white;\n                    padding: 0 5px;\n                    margin-bottom: 5px;\n                }\n                .question-answer:focus,\n                .question-answer:hover {\n                    outline: none;\n                    border-radius: 4px;\n                    border: 1px solid #cce4e2;\n                }\n                .question-answer:before {\n                    content: \"\";\n                    display: block;\n                    opacity: 0;\n                    position: absolute;\n                    transition-duration: 0.15s;\n                    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n                    bottom: 0;\n                    left: 0;\n                    right: 0;\n                    top: 0;\n                    background: #20a499;\n                    border-radius: 4px;\n                    transform: scale(0);\n                    transition-property: transform, opacity;\n                }\n                .question-answer:hover:before,\n                .question-answer:focus:before {\n                    transform: scale(1);\n                    opacity: 0.12;\n                }\n                .question-wrapper {\n                    width: 100%;\n                    padding-top: 10px;\n                    padding-bottom: 5px;\n                }\n                .correct-ans {\n                    color: green;\n                    text-align: center;\n                    margin-top: 25px;\n                }\n                .wrong-ans {\n                    color: red;\n                    text-align: center;\n                    margin-top: 25px;\n                }\n                .question-answer input[type=\"radio\"],\n                .question-answer input[type=\"checkbox\"] {\n                    margin: 20px 10px;\n                    position: relative;\n                    display: inline-block;\n                    vertical-align: middle;\n                }\n                .question-answer input[type=\"radio\"],\n                .question-answer input[type=\"checkbox\"] {\n                    background: #f3f3f3;\n                    width: 30px;\n                    height: 30px;\n                    border: 2px solid #366fb5;\n                    transition: all 0.3s linear;\n                    cursor: pointer;\n                    -webkit-appearance: none;\n                    appearance: none;\n                }\n                .question-answer input[type=\"radio\"] {\n                    border-radius: 50%;\n                }\n                .question-answer input[type=\"checkbox\"] {\n                    border-radius: 2px;\n                }\n                .question-answer input[type=\"radio\"]:checked,\n                .question-answer input[type=\"checkbox\"]:checked {\n                    background-color: #366fb5;\n                }\n                .question-answer input[type=\"radio\"]:focus,\n                .question-answer input[type=\"checkbox\"]:focus {\n                    outline: 0 none;\n                    box-shadow: none;\n                }\n                .question-para {\n                    position: relative;\n                    width: 100%;\n                    min-height: 42px;\n                }\n                .question-para {\n                    padding-top: 7px;\n                }\n                .question-para i,\n                .question-para b,\n                .question-para em,\n                .question-para sup,\n                .question-para sub {\n                    display: inline;\n                }\n            </style>\n            <div class=\"answer-wrapper\">\n                <label\n                    for=\"[[id]]\"\n                    tabIndex=\"-1\"\n                    style=\"cursor: pointer\"\n                    class$=\"[[config.rootClassName]]\"\n                >\n                    <div class$=\"[[config.className]]\">\n                        <input\n                            type=\"[[type]]\"\n                            name=\"[[id]]\"\n                            id=\"[[id]]\"\n                            checked=\"{{config.checked}}\"\n                            value=\"[[config.value]]\"\n                            on-change=\"handleChange\"\n                        />\n                        <div class=\"answer-caption\">\n                            <div class=\"question-para\">\n                                <slot></slot>\n                            </div>\n                        </div>\n                    </div>\n                </label>\n            </div>\n        `;\n  }\n\n  static get observers() {\n    return ['computeConfig(value, expect, showCorrect, review)'];\n  }\n\n  static get properties() {\n    return {\n      id: {\n        type: String,\n        value: 'default'\n      },\n      config: {\n        type: Object,\n        value: () => ({}),\n        notify: true,\n        readOnly: false\n      },\n      value: {\n        type: String,\n        value: \"false\",\n        notify: true,\n        readOnly: false\n      },\n      expect: {\n        type: String,\n        value: '',\n        readOnly: false\n      },\n      type: String,\n      answered: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        readOnly: false\n      },\n      showCorrect: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        readOnly: false\n      },\n      review: {\n        type: Boolean,\n        value: false,\n        notify: true,\n        readOnly: false\n      },\n      order: {\n        type: Number,\n        value: () => this.id\n      }\n    };\n  }\n\n  handleChange(e) {\n    e.stopPropagation();\n    const value = e.target[this.config.property];\n    this.set('value', value);\n    const event = new CustomEvent('selfstudyanswer', {\n      bubbles: true,\n      composed: true,\n      detail: {\n        value,\n        path: this.config.path,\n        id: this.id\n      }\n    });\n    this.dispatchEvent(event);\n  }\n\n  computeConfig(value, expect, showCorrect, review, hide) {\n    const oldConfig = this.config || {};\n    const config = Object.assign({}, oldConfig);\n\n    switch (this.type) {\n      case \"text\":\n        config.className = \"text-answer\";\n        config.path = \"value\";\n        config.value = value || \"\";\n        config.property = \"value\";\n        config.isCorrect = config.value === this.expect;\n        break;\n\n      case \"checkbox\":\n        config.value = this.id + 1;\n        config.path = `${this.id + 1}`;\n        config.className = \"checkbox\";\n        config.checked = truthy(value);\n        config.property = \"checked\";\n        config.isCorrect = config.checked === (expect === \"true\");\n\n        if (config.checked && !config.isCorrect) {\n          config.wronglySelected = true;\n        }\n\n        break;\n\n      case \"radio\":\n        config.value = this.id + 1;\n        config.path = `${this.id + 1}`;\n        config.className = \"radio\";\n        config.checked = truthy(value);\n        config.property = \"checked\";\n        config.isCorrect = config.checked === (expect === \"true\");\n\n        if (config.checked && !config.isCorrect) {\n          config.wronglySelected = true;\n        }\n\n        break;\n    }\n\n    const className = ['question-answer'];\n\n    if ((showCorrect || review) && config.isCorrect && config.checked) {\n      className.push(\"correct-answer\");\n    }\n\n    if ((showCorrect || review) && config.wronglySelected) {\n      className.push(\"wrong-answer\");\n    }\n\n    config.rootClassName = className.join(' ');\n\n    if (config.rootClassName !== oldConfig.rootClassName || config.className !== oldConfig.className) {\n      this.updateStyles();\n    }\n\n    this.config = config;\n  }\n\n}\n\nwindow.customElements.define('selfstudy-answer', Answer); /**\n                                                           * `polymer-element`\n                                                           * Sample element\n                                                           *\n                                                           * @customElement\n                                                           * @polymer\n                                                           * @demo demo/index.html\n                                                           */\n\nclass MyPolymerElement extends PolymerElement {\n  static get template() {\n    return html`\n            <style>\n                :host {\n                display: block;\n                }\n            </style>\n            <h2>Hello [[prop1]]!</h2>\n            <slot></slot>\n        `;\n  }\n\n  static get properties() {\n    return {\n      prop1: {\n        type: String,\n        value: 'polymer-element'\n      }\n    };\n  }\n\n}\n\nwindow.customElements.define('polymer-element', MyPolymerElement);\n\nfunction truthy$1(val) {\n  if (/^\\s*(true|1|on|yes|y)\\s*$/i.test(val)) {\n    return true;\n  }\n\n  if (/^\\s*(false|0|off|no|n)\\s*$/i.test(val)) {\n    return false;\n  }\n\n  return null;\n} /**\n   * `polymer-element`\n   * Sample element\n   *\n   * @customElement\n   * @polymer\n   * @demo demo/index.html\n   */\n\nclass Question extends PolymerElement {\n  static get template() {\n    return html`\n            <style>\n                :host {\n                    display: block;\n                    width: 100%;\n                }\n                .question-wrapper {\n                    width: 100%;\n                    padding-top: 10px;\n                    padding-bottom: 5px;\n                }\n                .question-para {\n                    position: relative;\n                    width: 100%;\n                    min-height: 42px;\n                }\n                .question-para {\n                    padding-top: 7px;\n                }\n                .question-para i,\n                .question-para b,\n                .question-para em,\n                .question-para sup,\n                .question-para sub {\n                    display: inline;\n                }\n                .question-number {\n                    float: left;\n                    width: 42px;\n                    height: 42px;\n                    line-height: 42px;\n                    margin: 0 10px 10px 0;\n                    border-radius: 50%;\n                    background-color: #20a499;\n                    color: white;\n                    font-weight: 600;\n                    text-align: center;\n                    display: inline-block;\n                }\n                .question-question {\n                    width: calc(100% - 52px);\n                    display: inline-block;\n                    margin-bottom: 10px;\n                    font-weight: normal;\n                    min-height: 42px;\n                }\n                .test-btn-wrap {\n                    width: 100%;\n                    text-align: center;\n                }\n                .test-btn {\n                    margin-top: 15px;\n                    display: block;\n                    width: 100%;\n                    position: relative;\n                    overflow: hidden;\n                }\n                .test-btn button {\n                    background: #366fb5;\n                    color: white;\n                    width: 6.5em;\n                    font-size: 100%;\n                }\n                .test-btn button:hover {\n                    box-shadow: 0 3px 3px 1px rgba(0, 0, 0, 0.14),\n                        0 3px 3px 1px rgba(0, 0, 0, 0.12), 0 5px 5px -3px rgba(0, 0, 0, 0.2);\n                }\n                .main-question {\n                    margin-top: 20px;\n                    margin-bottom: 20px;\n                    padding-top: 10px;\n                    padding-bottom: 10px;\n                }\n                .answer-list {\n                    display: flex;\n                    width: 100%;\n                    flex-direction: row;\n                    flex-flow: wrap;\n                }\n            </style>\n            <div class=\"main-question\" hidden$=\"{{!show}}\">\n                <div>Answers [[answered]]</div>\n                <div class=\"question-wrapper\">\n                    <div hidden$=\"{{!index}}\" class=\"question-number\">[[index]]</div>\n                    <div class=\"question-question question-para\">\n                        <slot name=\"stem\"></slot>\n                    </div>\n                </div>\n                <div class=\"answer-list\">\n                    <slot id=\"answers-slot\" name=\"answers\"></slot>\n                </div>\n                <div hidden$=\"{{!showConfidence}}\">\n                    <div class=\"test-btn-wrap\">\n                        <div class=\"test-btn\">\n                            <button\n                                class=\"btn\"\n                                disabled$=\"{{hasConfidence}}\"\n                                name=\"sure\"\n                                on-click=\"_handleConfidence\">\n                                I am Sure\n                            </button>\n                            <button\n                                class=\"btn\"\n                                style=\"opacity: 0.8;\"\n                                disabled$=\"{{hasConfidence}}\"\n                                name=\"unsure\"\n                                on-click=\"_handleConfidence\">\n                                I Think So\n                            </button>\n                            <button\n                                class=\"btn\"\n                                style=\"opacity: 0.6;\"\n                                disabled$=\"{{hasConfidence}}\"\n                                name=\"guess\"\n                                on-click=\"_handleConfidence\">\n                                Best Guess\n                            </button>\n                        </div>\n                    </div>\n                </div>\n                <div hidden$=\"{{!hasConfidence}}\" class=\"question-wrapper\">\n                    <slot name=\"explanation\"></slot>\n                </div>\n            </div>\n        `;\n  }\n\n  static get properties() {\n    return {\n      id: {\n        type: String,\n        value: \"default\"\n      },\n      index: {\n        type: String,\n        value: \"\"\n      },\n      answered: {\n        type: String,\n        notify: true,\n        readOnly: false,\n        value: \"\"\n      },\n      confidence: {\n        type: Boolean,\n        notify: true,\n        value: false\n      },\n      answer: {\n        type: Object,\n        notify: true,\n        readOnly: false,\n        value: () => ({})\n      },\n      preserve: {\n        type: Boolean,\n        notify: true,\n        readOnly: false\n      },\n      showConfidence: {\n        type: Boolean,\n        value: false,\n        notify: true\n      },\n      hasConfidence: {\n        type: Boolean,\n        value: false,\n        notify: true\n      },\n      show: {\n        type: Boolean,\n        value: false,\n        nofify: true\n      },\n      correct: {\n        type: Boolean,\n        value: false,\n        notify: true\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_checkConfidence(confidence, answer)'];\n  }\n\n  constructor() {\n    super();\n    this._listener = this._selfstudyAnswer.bind(this);\n    const answers = [].slice.call(this.querySelectorAll('selfstudy-answer'));\n    const preserve = truthy$1(this.getAttribute('preserve'));\n    this.expected = (this.getAttribute('expect') || '1').split(',').reduce((expect, val) => {\n      const [index, order] = val.split(':');\n\n      if (order) {\n        expect[index] = Number(order);\n      } else {\n        expect[index] = true;\n      }\n\n      return expect;\n    }, {});\n    this.exclusive = {};\n    answers.forEach((item, index) => {\n      if (!item.getAttribute('id')) {\n        item.setAttribute('id', `${index + 1}`);\n      }\n\n      if (item.getAttribute('type') === 'radio') {\n        this.exclusive[item.getAttribute('id')] = item;\n      }\n\n      if (preserve) {\n        item.setAttribute('order', item.getAttribute('id'));\n      } else {\n        item.setAttribute('order', Math.random());\n      }\n\n      item.setAttribute('path', index + 1);\n    });\n\n    if (!preserve) {\n      answers.sort(function (a, b) {\n        return a.getAttribute('order') - b.getAttribute('order');\n      });\n      let previous = null;\n\n      for (let index in answers) {\n        const answer = answers[index];\n\n        if (previous) {\n          answer.parentNode.insertBefore(previous, answer);\n        }\n\n        previous = answer;\n      }\n    }\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.addEventListener('selfstudyanswer', this._listener);\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeEventListener('selfstudyanswer', this._listener);\n  }\n\n  _checkConfidence(confidence, answer) {\n    answer = answer || {};\n\n    if (confidence) {\n      if (Object.keys(answer.choice || {}).length > 0) {\n        if (answer.confidence) {\n          this.set('hasConfidence', true);\n          this.set('showConfidence', false);\n        } else {\n          this.set('hasConfidence', false);\n          this.set('showConfidence', true);\n        }\n      } else {\n        this.set('hasConfidence', false);\n        this.set('showConfidence', false);\n      }\n    } else {\n      if (Object.keys(answer.choice || {}).length > 0) {\n        this.set('hasConfidence', true);\n      } else {\n        this.set('hasConfidence', false);\n      }\n    }\n\n    if (this.get('hasConfidence')) {\n      const event = new CustomEvent('selfstudyquestionanswer', {\n        bubbles: true,\n        composed: true,\n        detail: {\n          value: answer,\n          id: this.id\n        }\n      });\n      this.dispatchEvent(event);\n    }\n  }\n\n  _handleConfidence(e) {\n    const confidence = e.target.name;\n    const answer = Object.assign({}, this.answer || {});\n    answer.confidence = confidence;\n    this.set('answer', answer);\n\n    this._checkConfidence(this.confidence, this.answer);\n  }\n\n  _selfstudyAnswer(e) {\n    e.stopPropagation();\n    const answer = Object.assign(this.answer || {});\n    delete answer.confidence;\n    const {\n      id,\n      value,\n      path\n    } = e.detail || {};\n    let choice = Object.assign(answer.choice || {});\n\n    if (typeof value === 'boolean') {\n      if (value) {\n        choice[id] = Object.keys(choice).length + 1;\n\n        if (this.exclusive[id]) {\n          Object.keys(this.exclusive).forEach(key => {\n            if (id !== key) {\n              const item = this.exclusive[key];\n\n              if (truthy$1(item.value)) {\n                delete choice[key];\n                item.value = \"false\";\n              }\n            }\n          });\n        }\n      } else if (choice[id]) {\n        delete choice[id];\n      }\n\n      const temp = Object.keys(choice).map(key => {\n        return {\n          key,\n          value: choice[key]\n        };\n      });\n      temp.sort((a, b) => a.value - b.value);\n      choice = temp.reduce((choice, {\n        key\n      }, index) => {\n        choice[key] = index + 1;\n        return choice;\n      }, {});\n    }\n\n    answer.choice = choice;\n    const all = Object.assign({}, this.expected, choice);\n    let correct = Object.keys(all).reduce((correct, key) => {\n      if (!correct) {\n        return correct;\n      }\n\n      const value = this.expected[key];\n\n      if (typeof value === 'boolean') {\n        if (!choice[key]) {\n          return false;\n        }\n      } else {\n        if (value !== choice[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }, true);\n    answer.correct = correct;\n    this.set('correct', correct);\n    this.set('answered', Object.keys(choice).map(key => `${key}:${choice[key]}`).join(', ') + (correct ? ' correct!' : ''));\n    this.set('answer', answer);\n\n    this._checkConfidence(this.confidence, this.answer);\n  }\n\n}\n\nwindow.customElements.define('selfstudy-question', Question);\n\nfunction truthy$2(val) {\n  if (/^\\s*(true|1|on|yes|y)\\s*$/i.test(val)) {\n    return true;\n  }\n\n  if (/^\\s*(false|0|off|no|n)\\s*$/i.test(val)) {\n    return false;\n  }\n\n  return null;\n} /**\n   * `polymer-element`\n   * Sample element\n   *\n   * @customElement\n   * @polymer\n   * @demo demo/index.html\n   */\n\nclass QuestionSet extends PolymerElement {\n  static get template() {\n    return html`\n            <style>\n                :host {\n                    display: block;\n                    width: 100%;\n                }\n            </style>\n            <slot></slot>\n        `;\n  }\n\n  static get properties() {\n    return {\n      index: {\n        type: Number,\n        value: 0\n      },\n      answers: {\n        type: Object,\n        value: () => ({})\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_checkAnswers(answers)'];\n  }\n\n  constructor() {\n    super();\n    this._listener = this._selfstudyAnswer.bind(this);\n    this.questions = [].slice.call(this.querySelectorAll('selfstudy-question'));\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    this.addEventListener('selfstudyquestionanswer', this._listener);\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.removeEventListener('selfstudyquestionanswer', this._listener);\n  }\n\n  _checkAnswers(answers) {\n    let index = null;\n    this.questions.forEach((question, pos) => {\n      if (!answers[question.getAttribute('id')]) {\n        if (index == null) {\n          question.show = true;\n          index = pos;\n        } else {\n          question.show = null;\n        }\n      } else {\n        question.show = true;\n      }\n    });\n    this.set('index', index);\n  }\n\n  _selfstudyAnswer(e) {\n    e.stopPropagation();\n    const answers = Object.assign(this.answers || {});\n    const {\n      id,\n      value\n    } = e.detail || {};\n    answers[id] = value;\n    this.set('answers', answers);\n\n    this._checkAnswers(this.answers);\n  }\n\n}\n\nwindow.customElements.define('selfstudy-question-set', QuestionSet);\nexport { domModule as $domModule, elementMixin as $elementMixin, propertiesChanged as $propertiesChanged, propertiesMixin as $propertiesMixin, propertyAccessors as $propertyAccessors, propertyEffects as $propertyEffects, templateStamp as $templateStamp, async as $async, caseMap$1 as $caseMap, htmlTag as $htmlTag, mixin as $mixin, path as $path, resolveUrl$1 as $resolveUrl, settings as $settings, styleGather as $styleGather, polymerElement as $polymerElement$1, DomModule, ElementMixin, instanceCount, registrations, register, dumpRegistrations, updateStyles, PropertiesChanged, PropertiesMixin, PropertyAccessors, PropertyEffects, TemplateStamp, timeOut, animationFrame, idlePeriod, microTask, dashToCamelCase, camelToDashCase, html, htmlLiteral, dedupingMixin, isPath, root, isAncestor, isDescendant, translate, matches, normalize, split, get, set, isDeep, resolveUrl, resolveCss, pathFromUrl, useShadow, useNativeCSSProperties, useNativeCustomElements, rootPath, setRootPath, sanitizeDOMValue, setSanitizeDOMValue, passiveTouchGestures, setPassiveTouchGestures, stylesFromModules, stylesFromModule, stylesFromTemplate, stylesFromModuleImports, cssFromModules, cssFromModule, cssFromTemplate, cssFromModuleImports, html as html$1, PolymerElement };"]}